---
title: 求取质数素数的几种方式
date: 2018-07-08 12:07:28
tags: [数据结构与算法]
---



质数/素数在数学上定义为只能被1或者自身整除的数。道德经中的宇宙观为，“道生一，一生二，二生三，三生万物”。<!-- more --> 所以任何物质都是由几个基本元素组成合成新的事物，对于数学的数字似乎也是这样，在大的数字，也是由一些基本的数字相乘而得到，而这些基本的数字，就是质数。关于质数仍旧有很多问题未能解决，感兴趣的参见 [质数](https://zh.wikipedia.org/wiki/%E7%B4%A0%E6%95%B0) 了解。

在程序设计中，质数判断是常见的问题，这里总结一下常见的几种方式。0,1默认不是质数。

### 定义法

从定义本身出发，判断一个数n 是否为质数，除去1和本身，那就看它是否能被 2~n-1 中的数整除，若能整除则不是，则不能，则是。

```java
    /**
     * Solution1：最基本的定义法  质数 他数整数 效率低
     */
    public static boolean isPrimeSolution1(int n) {
        if (n == 0 || n == 1) {
            return false;
        }
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```

当然效率是非常低的，对于很大的数，是要计算很久，因为毕竟要逐一进行整除判断

### 定义改进1(缩小范围)

那么是否判断范围从 2~n-1呢？这里其实可以在继续缩短比较范围，范围为 $[2 ,\sqrt{n}]$  即可。为什么呢？因为假设一个数是合数（也就是非质数），一定是由其他两个数相乘得到，那么其中一个必然小于它的开根号数，另一个必然大于它的开根号数，这点可以从反证法判断，如果相乘的两个数都小于开方数，那么乘积必然小于该数，假设不成立。所以改进如下。

```java
    /**
     * Solution2: 定义法改进 思路： 不必判断该数 是否能整除 2~n-1。可
     * 小范围。2~sqrt(n)。因为若一个数是合数
     * （也就是由其他两个数乘积得到），那么其中一个必然小于它的开方数，另一个必然大于（反证法证明，
     * 如果两个都小于开方数，那么乘积就会小于该数，不符合）
     */
    public static boolean isPrimeSolution2(int n) {
        if (n == 0 || n == 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```

### 定义改进2(再排除偶数）

上面是从判断整除范围角度缩小，那其实从定义出发，能在删除一半的数-偶数，如果是偶数，肯定不是质数，因为偶数一定能被2整除，所以概述肯定不是质数，这就又删除一半的，只考虑奇数。

```java
    public static boolean isPrimeSolution3(int n) {
        if (n == 0 || n == 1) {
            return false;
        }
        if (n > 2 && n % 2 == 0) {// 排除偶数
            return false;
        }
        int sqrtValue = (int) Math.sqrt(n);
        for (int i = 3; i <= sqrtValue; i += 2) {//奇数
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```

### 筛选法

通常可以利用筛选法，求出某个范围内的所有质数。它的原理依然利用质数的性质，不能是任何质数的倍数，逐一排除。其实看到偶数，其实就不是质数，因为2是质数，偶数一定能被2整除，所以偶数一定不是质数。它的思路为，假设求取20以内的质数。

1. 先开辟一个容量为20的boolean 类型数组` primeArray[20]`，并全部初始化为 true。索引为该值，值为true,则表示该值为质数，false则不是，例如` primeArray[0]=false`. 则表示0不是质数
2. 初始化0,1为非质数。从质数开始，删除该质数的所有的倍数
   1. 从2开始，逐一删除掉 它的倍数(2倍，3倍，4倍...) ，直到超过选定的数据范围
   2. 在从3开始，逐一删除掉它的倍数，重复以上
   3. 直到所有超过数据范围

```java
    /***
     * Solution3: 筛选法：
     * 思路：假定求取 20 以内的素数。那么先初始化一个30boolean 类型数组，都初始化为true,
     * 数组索引都对应该数字，里面的值表示是否是质数。如 primeArray[0]=false, 表示 0不是质数。
     * 筛的原理为，逐一去掉倍数的值，也就是能整除的值。
     * 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20
     * 0,1 索引处，初始化为 false. 从2开始
     * 那么2的2倍，3倍，4倍..直到数值超出。筛选一次后，2,3,5,7,11,13,15,17,19
     * 那么在接着3开始，3也是质数。3的2倍，3倍。。直到超过。筛选后，2,3,5,7,11,13,17,19
     * 接着从索引为4，4不是质数，跳过，依次类推。
     * 
     * 这样可以存储指定大小的质数数组，查找就直接获取值
     */
    public static boolean[] primeArray = new boolean[100];

    public static void initPrimeArray(int n) {
        Arrays.fill(primeArray, true);
        primeArray[0] = primeArray[1] = false;
        for (int i = 2; i < n; i++) {
            if (primeArray[i]) {
                for (int j = 2; i * j < primeArray.length; j++) {
                    primeArray[i * j] = false;
                }
            }
        }
    }

    public static boolean isPrimeSolution3(int n) {
        return primeArray[n];
    }
```

完整的Java 测试工程见 [github](https://github.com/cloudy-liu/BDSA/tree/master/Algorithm/%E7%B4%A0%E6%95%B0)