---
title: 七大排序算法之冒泡排序(1)
date: 2018-06-14 23:09:33
tags: [Java,数据结构与算法]
---

这节开始总结一些基本的排序算法，先来看看最简单的冒泡算法。<!-- more --> 

我们假设测试数据集为以下数组，要求按照从小到达的升序排列。

```
1,2,3,4,5,6,7,8,9,10  # 正序
21,1,5,2,3,4,7,9,10   # 普通乱序
10,9,8,7,6,5,4,3,2,1  # 逆序
```

### 思路

相邻比较和交换的方法。第一轮确定最右边的数最大，第二轮确定倒数第二大的数，一共有n-1轮要遍历。

### 流程举例

我们以普通乱序的测试数据举例，数组长度为9，那么遍历 8 轮(n-1)。第一次

```
21,1,5,2,3,4,7,9,10 
1,5,2,3,4,7,9,10,21 # 第一轮后 最大的21就冒到最后了，位置唯一确定
1,2,3,4,5,7,9,10,21 # 第二轮后 已经全部有序了
```

### Java 实现 

先实现交换的辅助函数

```Java
    public void swap(int[] a, int indexI, int indexJ) {
        if (a == null || indexI >= a.length || indexJ >= a.length) {
            System.out.println("a is null ,index out of bound");
            return;
        }
        int tmp = a[indexI];
        a[indexI] = a[indexJ];
        a[indexJ] = tmp;
    }
```

冒泡排序实现

```java
    public void bubbleSort(int[] input) {
        int rightSide = input.length;
        while (rightSide - 1 > 0) { // 控制比较次数，比较次数为 len-1
            for (int i = 1; i < rightSide; i++) { //每轮下两两比较
                if (input[i - 1] > input[i]) {
                    swap(input, i - 1, i);
                }
            }
            --rightSide;
        }
    }
```

### 复杂度分析

排序算法的时间复杂度在于交换和比较的次数，因此交换和比较次数的总和越小，那么时间复杂度越低，冒泡排序一个有 n 轮的遍历，每轮遍历中，比较次数依次为 n-1,n-2,...1 。因此比较次数的总和为

$sum=\sum_{1}^{n-1}=1+2+...+n-1=\dfrac{n(n-1)}{2}$ 为 $O(n^2)$

最差情况下（逆序），那么比较一次，就要交换一次。而最好的情况下，已序的情况下，上述还是需要在比较n多次。

### 优化

你可以看到，当测试集为正序时候，仍然需要$O(n^2)$ 的复杂度，其实每一轮遍历中，两两比较，若整个序列没有发生交换，其实排序就已经可以停止了，比如正序情况下，第一轮两两比较时，由于都是正序，所以一边遍历后没有任何交换，此时就需要停止了。若发生交换，则记录最后一个交换的位置，则该位置为下次交换遍历的终点位置。减少不必要的比较。代码如下

```java
    public void bubbleSortOpt(int[] input) {
        int rightSide = input.length;
        int lastCompareIndex = rightSide;//记录最后一个比较的右边界，同时充当哨兵，是否停止
        while (lastCompareIndex > 0) {//是否要停止
            lastCompareIndex = 0; //若未发生交换，则会停止
            for (int i = 1; i < rightSide; i++) {
                if (input[i - 1] > input[i]) {
                    swap(input, i - 1, i);
                    lastCompareIndex = i;//记录最后一个发生交换的位置，下次比较的右边界
                }
            }
        }
    }
```

这样复杂度，在最好的情况下（已经有序），可以变为$O(n)​$ 

### 总结

冒泡排序基于交换和计较，基于改进后的冒泡，时间复杂度有所改善。最好情况已排好的状态下为 $O(n)$ ,完全最差情况下逆序情况下 $O(n^2)$ 