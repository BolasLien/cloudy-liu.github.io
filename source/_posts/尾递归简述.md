---
title: 尾递归简述
date: 2018-06-22 23:14:14
tags: 数据结构与算法
---



在上一章节中的排序算法中，可以到递归调用是一种思路非常清晰，易于简化的方式，但是副作用就是调用栈的开销。<!-- more --> 

###  递归的开销

一般计算机语言实现，方法调用都是放在栈帧中执行，这里以Java 为例，从java的内存模型来看，方法的调用是在 Java stack 中，也就是java 栈中，方法的嵌套会形成一个嵌套的调用栈，栈内主要存储的是方法的局部变量和方法参数，在该方法执行完毕后，该栈被销毁。但是栈总有一个深度的极限值，超过了该极限值，会发生栈溢出。所以在编码时候，为了效率，尽可能的要将递归转为迭代实现。

### 什么是尾递归

从上面定义可看出，递归对方法栈的消耗，一大部分都是在局部变量和参数，假设可以节省局部变量，势必会减少栈的消耗。减少空间复杂度。尾递归的本质是将函数的临时返回值，变为函数的参数实现的。

### 举例与性能测试

我们这里实现集中斐波那契数列，分析一下它的运行时间的消耗。

#### 递归实现

没什么好解释的，直接看代码

```java
    public static long fibRecursion(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 0 || n == 1) {
            return n;
        }
        return fibRecursion(n - 1) + fibRecursion(n - 2);
    }
```

时间的瓶颈主要在递归调用，非常多的重复的计算，造成性能差，时间复杂度为$O(n^2)$。空间复杂度 $O(logn)$,比如计算 F(5)  -> f(4),f(3) ->f(3),f(2),f(2),f(1) -> f(2),f(1),f(1),f(0) ，可以看到大量的重复计算。

#### 尾递归

尾递归其实算是一种迭代的方式，将结果放在参数位置，从而不产生局部变量。

```java
    //尾递归实现
    public static long fibTailRecursion(int n, int fibResult, int fibPlusOne) {
        if (n == 0) {
            return fibResult;
        }
        return fibTailRecursion(n - 1, fibResult + fibPlusOne, fibResult);
    }
```

#### 迭代实现

从前往后计算，减少了重复，时间复杂度为 $O(n)$ 

```java
    //迭代实现
    public static long fibIter(int n) {
        if (n < 0) {
            return 0;
        }
        if (n == 0 || n == 1) {
            return n;
        }

        long fibPlusOne = 1;
        long fibPlusTwo = 0;
        long rst = 0;

        for (int i = 1; i < n; i++) {
            rst = fibPlusOne + fibPlusTwo;
            fibPlusTwo = fibPlusOne;
            fibPlusOne = rst;
        }
        return rst;
    }
```

性能对比。可以看出 迭代和尾递归效果差并不多，在40个数据量的时候。

```java
    public static void main(String[] args) {
        int fibValue = 40;
        long start = System.currentTimeMillis();
        for (int i = 0; i < fibValue; i++) {
            try {
                fibRecursion(i);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        System.out.println("Recursion spend : " + (System.currentTimeMillis() - start) + " ms");

        start = System.currentTimeMillis();
        for (int i = 0; i < fibValue; i++) {
            fibTailRecursion(i, 0, 1);
        }
        System.out.println("tail Recursion spend : " + (System.currentTimeMillis() - start) + " ms");

        start = System.currentTimeMillis();
        for (int i = 0; i < fibValue; i++) {
            fibIter(i);
        }
        System.out.println("iter spend : " + (System.currentTimeMillis() - start) + " ms");
    }
}

/* output
Recursion spend : 1562 ms
tail Recursion spend : 0 ms
iter spend : 0 ms
 */
```

