[{"title":"七大排序算法之冒泡排序(1)","slug":"七大排序算法之冒泡排序(1)","date":"2018-06-14T15:09:33.000Z","updated":"2018-06-15T00:40:30.585Z","comments":true,"path":"2018/06/14/七大排序算法之冒泡排序(1)/","link":"","permalink":"https://www.liuyun.fun/2018/06/14/七大排序算法之冒泡排序(1)/","excerpt":"这节开始总结一些基本的排序算法，先来看看最简单的冒泡算法。","text":"这节开始总结一些基本的排序算法，先来看看最简单的冒泡算法。 我们假设测试数据集为以下数组，要求按照从小到达的升序排列。 1231,2,3,4,5,6,7,8,9,10 # 正序21,1,5,2,3,4,7,9,10 # 普通乱序10,9,8,7,6,5,4,3,2,1 # 逆序 思路相邻比较和交换的方法。第一轮确定最右边的数最大，第二轮确定倒数第二大的数，一共有n-1轮要遍历。 流程举例我们以普通乱序的测试数据举例，数组长度为9，那么遍历 8 轮(n-1)。第一次 12321,1,5,2,3,4,7,9,10 1,5,2,3,4,7,9,10,21 # 第一轮后 最大的21就冒到最后了，位置唯一确定1,2,3,4,5,7,9,10,21 # 第二轮后 已经全部有序了 Java 实现先实现交换的辅助函数 123456789public void swap(int[] a, int indexI, int indexJ) &#123; if (a == null || indexI &gt;= a.length || indexJ &gt;= a.length) &#123; System.out.println(\"a is null ,index out of bound\"); return; &#125; int tmp = a[indexI]; a[indexI] = a[indexJ]; a[indexJ] = tmp;&#125; 冒泡排序实现 1234567891011public void bubbleSort(int[] input) &#123; int rightSide = input.length; while (rightSide - 1 &gt; 0) &#123; // 控制比较次数，比较次数为 len-1 for (int i = 1; i &lt; rightSide; i++) &#123; //每轮下两两比较 if (input[i - 1] &gt; input[i]) &#123; swap(input, i - 1, i); &#125; &#125; --rightSide; &#125;&#125; 复杂度分析排序算法的时间复杂度在于交换和比较的次数，因此交换和比较次数的总和越小，那么时间复杂度越低，冒泡排序一个有 n 轮的遍历，每轮遍历中，比较次数依次为 n-1,n-2,…1 。因此比较次数的总和为 $sum=\\sum_{1}^{n-1}=1+2+…+n-1=\\dfrac{n(n-1)}{2}$ 为 $O(n^2)$ 最差情况下（逆序），那么比较一次，就要交换一次。而最好的情况下，已序的情况下，上述还是需要在比较n多次。 优化你可以看到，当测试集为正序时候，仍然需要$O(n^2)$ 的复杂度，其实每一轮遍历中，两两比较，若整个序列没有发生交换，其实排序就已经可以停止了，比如正序情况下，第一轮两两比较时，由于都是正序，所以一边遍历后没有任何交换，此时就需要停止了。若发生交换，则记录最后一个交换的位置，则该位置为下次交换遍历的终点位置。减少不必要的比较。代码如下 12345678910111213public void bubbleSortOpt(int[] input) &#123; int rightSide = input.length; int lastCompareIndex = rightSide;//记录最后一个比较的右边界，同时充当哨兵，是否停止 while (lastCompareIndex &gt; 0) &#123;//是否要停止 lastCompareIndex = 0; //若未发生交换，则会停止 for (int i = 1; i &lt; rightSide; i++) &#123; if (input[i - 1] &gt; input[i]) &#123; swap(input, i - 1, i); lastCompareIndex = i;//记录最后一个发生交换的位置，下次比较的右边界 &#125; &#125; &#125;&#125; 这样复杂度，在最好的情况下（已经有序），可以变为$O(n)​$ 总结冒泡排序基于交换和计较，基于改进后的冒泡，时间复杂度有所改善。最好情况已排好的状态下为 $O(n)$ ,完全最差情况下逆序情况下 $O(n^2)$","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.liuyun.fun/tags/Java/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://www.liuyun.fun/tags/数据结构与算法/"}]},{"title":"Windows 运行 tensorboard 1.6","slug":"Windows运行tensorboard1.8","date":"2018-05-31T15:10:31.000Z","updated":"2018-05-31T16:35:48.957Z","comments":true,"path":"2018/05/31/Windows运行tensorboard1.8/","link":"","permalink":"https://www.liuyun.fun/2018/05/31/Windows运行tensorboard1.8/","excerpt":"本篇讲述一下 Windows 环境下如何运行 Tensorboard 可视化 graph.","text":"本篇讲述一下 Windows 环境下如何运行 Tensorboard 可视化 graph. 环境 Windows 7 tensorflow 1.6/1.8 tensorlfow 1.6 在 windows 上通过 pip3 install tensorflow 安装，同时会顺带安装 tensorboard 工具，1.6 版本已经修改过了文件路径，具体的使用方式，参看如下例子。本机是1.8版本，1.6 也同样适用。 例子创建 model首先我们新建一个 test.py, 编写一个最简单的矩阵乘法，最后将其graph 保存下来，代码如下， 123456789101112131415import tensorflow as tfx = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3], name=\"x\")w = tf.constant([1, 2, 3, 4, 5, 6], shape=[3, 2], name=\"w\")b = tf.constant([1, 2, 3, 4], shape=[2, 2], name=\"b\")y = tf.matmul(x, w)+b # 计算 y=x*w +b 的模型with tf.Session() as sess: rst = sess.run(y) print(\"rst:\", rst) tf.summary.FileWriter(\"log\", graph=sess.graph) # 保存graph 到 当前文件 log目录下&gt;&gt;&gt; 输出结果rst: [[23 30] [52 68]] 运行完毕后，会在文件的当前路径，创建一个 log 文件夹，里面存有 graph 的信息，我本地目录结构如下 1234-- tmp -- log --- events.out.tfevents.1527778757.PC007 -- test.py 使用 tensorboard 查看可视化图形因为安装了 tensorflow 后，tensorboard 是会自动安装，如何运行文件呢？在终端中运行。 ctrl + R -&gt; 输入cmd -&gt; 回车，进行终端。然后运行如下命令，最后启动一个本地服务器。如下图所示，其实运行的是 tensorboard包下 main.py 文件。格式为 py -3 xx/tensorboard/main.py --logdir=path path就是你在tensorflow 保存时的路径。 1py -3 C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages\\tensorboard\\main.py --logdir=D:/tmp/log 然后在 chrome 浏览器中输入终端出现的信息 http:cloudy:6066 ，回车即可看到图形了 遇到的错误 chrome 浏览器需要升级。刚开始时候，我chrome 浏览器啥都不可见，升级一下 chrome 浏览器 就好了，我目前的版本是 版本 67.0.3396.62（正式版本） （32 位）。","categories":[],"tags":[{"name":"ML","slug":"ML","permalink":"https://www.liuyun.fun/tags/ML/"},{"name":"Tensorflow","slug":"Tensorflow","permalink":"https://www.liuyun.fun/tags/Tensorflow/"}]},{"title":"基于Java 7/8 的 HashMap 源码解析","slug":"JavaHashMap源码解析","date":"2018-04-22T03:38:33.000Z","updated":"2018-05-31T16:31:57.776Z","comments":true,"path":"2018/04/22/JavaHashMap源码解析/","link":"","permalink":"https://www.liuyun.fun/2018/04/22/JavaHashMap源码解析/","excerpt":"本篇我们来看看数据结构中一个非常基础的应用，哈希表。","text":"本篇我们来看看数据结构中一个非常基础的应用，哈希表。 Java 7 的实现HashMap.java 基本原理讲解 什么是哈希表(hash table) 我们看下维基百科对哈希（hash) 的解释， 散列（英语：Hashing）是电脑科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表） 也就是说，哈希表就是用来快速查找用的，哈希函数（也称为散列函数）就是用来生成检索的索引（index)的。 内部数据结构架构 基本流程概述 默认table的初始大小为 16, 12132 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16144 static final float DEFAULT_LOAD_FACTOR = 0.75f; 源码剖析流程 文件路径 构造函数，默认初始化容量为 16，加载因子为0.75 123280 public HashMap() &#123;281 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); 282 &#125; 接着调用带参数的构造函数，初始化加载因子和 threshold 1234567891011121314250 public HashMap(int initialCapacity, float loadFactor) &#123;251 if (initialCapacity &lt; 0)252 throw new IllegalArgumentException(\"Illegal initial capacity: \" +253 initialCapacity);254 if (initialCapacity &gt; MAXIMUM_CAPACITY)255 initialCapacity = MAXIMUM_CAPACITY;256 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))257 throw new IllegalArgumentException(\"Illegal load factor: \" +258 loadFactor);259 260 this.loadFactor = loadFactor;261 threshold = initialCapacity;262 init();//为空263 &#125; put 函数 123456789101112131415161718192021222324490 public V put(K key, V value) &#123;491 if (table == EMPTY_TABLE) &#123; //初始化默认大小的table，表的大小为16，同时更新下次resize的阈值threhold=12,(大小*加载因子）492 inflateTable(threshold); 493 &#125;494 if (key == null)//处理 Key=null case, HashMap 允许 key为null495 return putForNullKey(value);496 int hash = hash(key);//获取该key的 hash值497 int i = indexFor(hash, table.length);//获取该key映射对应的数组索引 //若key相同，则做value的更新操作，然后返回，否则就插入新的节点498 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;499 Object k;500 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;501 V oldValue = e.value;502 e.value = value;503 e.recordAccess(this);504 return oldValue;505 &#125;506 &#125;507 508 modCount++;509 addEntry(hash, key, value, i);//采用头部插入法，插入新的链表节点510 return null;511 &#125; 12345678315 private void inflateTable(int toSize) &#123;316 // Find a power of 2 &gt;= toSize,确保 capacity为最小的2的整数次幂317 int capacity = roundUpToPowerOf2(toSize);318 //增长阈值为容量*加载因子，首次的阈值为 16*0.75=12319 threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);320 table = new Entry[capacity];//初始化table，开始时大小为 16321 initHashSeedAsNeeded(capacity); //初始化 hash mask 值322 &#125; 1234567891011121314151617181920212223242526272829303132333435881 void addEntry(int hash, K key, V value, int bucketIndex) &#123; //若此时table的size 不小于阈值了且刚插入的这个值又冲突了，重新调整大小882 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; // 将table数组大小扩容为2倍，数组大小发生变化，所以 hash,index都需重新计算一次883 resize(2 * table.length);884 hash = (null != key) ? hash(key) : 0;885 bucketIndex = indexFor(hash, table.length);886 &#125;887 899 void createEntry(int hash, K key, V value, int bucketIndex) &#123; //查找到位于table数组中位置的节点900 Entry&lt;K,V&gt; e = table[bucketIndex]; //采用头部插入法插入节点,也就是若每次发生冲突，则都将新的节点插入到链表首位901 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);902 size++;903 &#125; 576 void resize(int newCapacity) &#123; //获取旧table，以及数据容量大小577 Entry[] oldTable = table;578 int oldCapacity = oldTable.length;579 if (oldCapacity == MAXIMUM_CAPACITY) &#123;580 threshold = Integer.MAX_VALUE;581 return;582 &#125;583 //重新new了一个数组584 Entry[] newTable = new Entry[newCapacity]; //旧table到新table做数据迁移585 transfer(newTable, initHashSeedAsNeeded(newCapacity));586 table = newTable; //更新 threhold，比如初始化表的大小16，扩容2倍为32，,此时resize的阈值为 32*0.74=24.587 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);588 &#125; 123456789101112131415593 void transfer(Entry[] newTable, boolean rehash) &#123;594 int newCapacity = newTable.length;595 for (Entry&lt;K,V&gt; e : table) &#123;596 while(null != e) &#123;597 Entry&lt;K,V&gt; next = e.next;598 if (rehash) &#123;599 e.hash = null == e.key ? 0 : hash(e.key);600 &#125;601 int i = indexFor(e.hash, newCapacity);602 e.next = newTable[i];603 newTable[i] = e;604 e = next;605 &#125;606 &#125;607 &#125; get方法 12345678418 public V get(Object key) &#123; // key为null情况，单独处理419 if (key == null)420 return getForNullKey();421 Entry&lt;K,V&gt; entry = getEntry(key);422 423 return null == entry ? null : entry.getValue();424 &#125; 获取Entry，查找到并且返回。 12345678910111213141516461 final Entry&lt;K,V&gt; getEntry(Object key) &#123;462 if (size == 0) &#123;463 return null;464 &#125;465 466 int hash = (key == null) ? 0 : hash(key);467 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];468 e != null;469 e = e.next) &#123;470 Object k;471 if (e.hash == hash &amp;&amp;472 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))473 return e;474 &#125;475 return null;476 &#125; Overview继承关系HashMap 继承于 AbstractMap 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; 实例源码分析123456789import java.util.HashMap;public class Test &#123; public static void main(String[] args) &#123; HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); hm.put(\"one\", 1); System.out.println(\"hm: \" + hm); &#125;&#125; HashMap源代码 构造函数初始化 加载因子 0.75 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; put方法key 为 “one”, value 为 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 会用到内置方法 putVal ，首先会将 key 做 hash 计算，我们接着看下 hash()方法 12 调用 Key 对象的 hashCode()方法生成 hash值，对于整数，哈希值就是它自己，对于字符串，它的值如下，可以查看相应的 hashCode() 方法，结果就是得到 32位的 hash值。 $hash = s[0]31^{n-1} + s[1]31^{n-2}+…+s[n-1]$ 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; Android的优化","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.liuyun.fun/tags/Java/"},{"name":"HashMap","slug":"HashMap","permalink":"https://www.liuyun.fun/tags/HashMap/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://www.liuyun.fun/tags/数据结构与算法/"}]},{"title":"Hexo yilia 主题一揽子使用方案","slug":"Hexo_yilia_主题一揽子优化方案","date":"2018-04-07T12:25:33.000Z","updated":"2018-04-07T14:19:17.425Z","comments":true,"path":"2018/04/07/Hexo_yilia_主题一揽子优化方案/","link":"","permalink":"https://www.liuyun.fun/2018/04/07/Hexo_yilia_主题一揽子优化方案/","excerpt":"在用 Hexo 搭建完毕后，接着就寻找主题了，对比了几个主题","text":"在用 Hexo 搭建完毕后，接着就寻找主题了，对比了几个主题 ，发现这个yilia 主题比较干净，简洁，于是就选了这个主题，但是有些细节不太习惯，于是就研究调整了一下，就是现在这个博客的样子。 查看所有文件，提示缺失模块yilia 在首次使用时，点击所有文章 时，会出现模块找不到的错误，可按照提示操作即可注意一下，_config.yml 路径是指 根目录下的，而非 yilia 主题下的 config文件 配置图片资源 添加图片资源文件夹。 路径为 themes/yilia/source/下，可添加一个 assets 文件夹，里面存放图片资源即可 配置文件中直接引用即可。路径为 themes/yilia/_config.yml，找到如下即可 123456# 微信二维码图片weixin: /assets/img/wechat.png# 头像图片avatar: /assets/img/head.jpg# 网页图标favicon: /assets/img/head.jpg 文章如何显示摘要 问题。点击主页时，发现所有文章都是全文显示，不利于查找，可控制显示的字数 解决办法。 在你 MD 格式文章正文插入 &lt;!-- more --&gt;即可，只会显示它之前的，此后的就不显示，点击文章标题，全文阅读才可看到，同时注释掉以下 themes/yilia/_config.yml，重复 1# excerpt_link: more 效果 文章显示目录增加文章目录 TOC(table of content )，方便阅读文章, 在 themes/yilia/_config.ym中进行配置 toc: 2即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。 增加归档菜单修改 themes/yilia/_config.yml 123menu: 主页: / 归档: /archives/index.html 修改代码块样式默认的代码样式太刺眼了，调成稍微柔和一些的，这里是调成 Atom 风格，以下为两种方式都可以，推荐第一种直接修改编译好的文件，不然还需要重新build。 直接修改编译好的文件。路径为： theme\\yilia\\source\\main.0cf68a.css 修改代码背景色，搜索 .article-entry .highlight, 修改background后面的颜色 修改代码字体颜色 .article-entry .highlight .line 修改源文件重新build。上述资源对应源文件为 yilia\\source-src\\css\\highlight.scss，按照如下方式build 1234cd 到 yilia 目录下npm installnpm run devnpm run dist 增加不蒜子统计利用这个统计，可以知道你博客的访问量 安装不蒜子脚本在 themes\\yilia\\layout\\_partial\\after-footer.ejs最后添加 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 添加统计网站访问量修改 themes\\yilia\\layout\\_partial\\footer.ejs，包括访客数和站点访问总量 12345# PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 单篇文章点击量在需要显示的地方添加 12# 使用 pv 记录方式，每访问一次，记录一次&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加来必力评论系统点击这个链接 查看 添加版权信息点击这个链接 查看 插入网易云音乐 登入网易云音乐网页版，选择一首歌，点击歌曲详情，点击生成外链播放器 复制外链代码，插入你需要编辑的 MD 格式文章里面，即可 百度/Google统计/SEO点击这个链接查看，这几项都是相同的 七牛云图床博客内容最麻烦的就是插入图片，我们可以使用七牛云提供的 10G 的免费存储空间，将图片上传上去，然后生成外链，使用 Markdown 的图片引用方法即可，这样文章就脱离了图片编辑，转为在线了。同样一份文章，你部署在 csdn 等其他网页时，直接复制粘贴即可。 上传图片到七牛云 注册，并完成支付宝实名认证，实名认证后有10G的免费空间，认证免费额度 添加文件。步骤为添加 对象存储, 新建一个存储空间，进入到该空间，点击 内容管理,点击上传文件 生成外链插入到文章中 使用 PicGo 自动生成外链但是这样通过 web点击上传按钮方式，太效率了，这里使用 PicGo 工具，完成拖动自动生成外链，感谢作者。 查看你的七牛密钥。登入七牛云查看密钥 个人面板 -&gt; 密钥管理 PicGo 配置七牛账户。然后就在上传图，拖动图片进去，即可生成外链，直接插入到文章中即可。 Demo测试修改配置后，输入以下三条命令即可部署 123hexo cleanhexo ghexo d 点击这里 查看博客正文的效果 以上希望对你所有帮助。 （全文完）","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuyun.fun/tags/Hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://www.liuyun.fun/tags/yilia/"}]},{"title":"从经济学思维出发","slug":"从经济学思维出发_","date":"2018-03-11T12:25:33.000Z","updated":"2018-04-06T11:41:44.565Z","comments":true,"path":"2018/03/11/从经济学思维出发_/","link":"","permalink":"https://www.liuyun.fun/2018/03/11/从经济学思维出发_/","excerpt":"司马迁在 &lt;货殖列传&gt; 中说 “天下熙熙，皆为利来，天下攘攘，皆为利往“","text":"司马迁在 &lt;货殖列传&gt; 中说 “天下熙熙，皆为利来，天下攘攘，皆为利往“，以前我觉得这句话未免太过现实，心中还是有多少抵触，难道社会不讲感情了吗？我一直很好奇现代社会是如何发展至今的，其背后的规律是什么，达尔文的进化论是否仍旧有效，现代商业化世界中各种让人头晕的名词是什么意思，商业的背后逻辑是什么？带着这些好奇，我开始利用闲暇时间，学习得到上薛兆丰老师的北大经济学，希望系统的学习经济学思维，进行一次认知和思维的升级。学习最好的方式是翻转式学习，就是将学习到的东西简洁有效的做输出，这是第一次输出。 开篇薛老师就讲了一个故事说明经济学是普遍存在的这个道理，讲的是二战的一个战俘营里的故事，战俘刚进战俘营时，大家还会相互有爱心，但是人毕竟有物质生活的基本需求，要生存，而生存的质量好坏，光靠爱心是不够的，一方无限给予，他就不能生存了，所以真正长久的还是需要靠商品和服务的交换，只有交换才能才是平衡，才能让整个群体生存下去。 同时战俘营的生活也有各种经济现象，有了交换，就需要货币作为流通，战俘营当然没有钱币这种东西，所以就用香烟替代，有个货币就有价格，比如面包能换几根香烟，都有明码标价，除了实物交换，还产生了其他”服务行业“，比如帮别人洗衣服，熨衣服等。既然商品有了价格，就会有价格的波动，比如红十字会是每周四和周日发面包，那什么时候面包是最紧缺的？是在派发面包的前一天，此时面包的价格是最贵的，因为大部分人是等不到发面包就吃完了，而一旦面包发了，那么面包的价格又降下来了。 同时有了货币就会有劣币驱逐良币的现象，他们会把好的香烟拆开，里面混进些头发丝之类的充数。也会有宏观经济的波动，比如通货紧缩和通货膨胀，比如每次战俘营旁边发生空袭的时候，战俘们觉得生命很可能就完了，还存那么多香烟干嘛，今朝有酒今朝醉，所以就开始吸平时不舍得的香烟，等到第二天发现安然无恙，此时香烟就紧缺了，又比如听说红十字会会送来一批香烟过来，所有的商品就会跟着涨价，但是后面被证实是假消息，这就是泡沫，商品又恢复到常规价格了。此外有人就有情绪，就会有舆论，会讨论交易是否道德。这些在生活随处可见的经济现象在战俘营也存在。 人处在社会之中，就要受到各种制度的约束，比如法律。那么这些制度定义的是什么？是为了公平吗？这里薛老师又讲了一个马粪案的故事，说原告和他的两个助手在街上捡马粪，忙会了一会儿，把马粪堆到一起后，就回去取车来拉，后来被告经过看到后，就问巡逻的人，这个是否有主人，巡逻的说不知道，被告就自己拉走了，撒到自己田里去了，后来原告回来看到，就和被告理论，最后打起了官司。 原告说这是他们付出劳动堆积起来的，所以马粪应该归他们，而被告说不对，马粪掉到地上，它就属于地上的一部分，这个地是公家的，所以不属于原告，原告只是改变了马粪的所在位置，并未改动过它的所有权，所以马粪不归原告所有。如果你是法官怎么判？这个案子本身并没有什么，最重要的是给后世留下什么样的指导意义，是鼓励人们靠劳动创造财富，还是鼓励人们只要没有做标记，就可以据为己有，以后的社会发展又会怎样。所以制度的建立是要指导未来社会和经济的发展，公平背后就是最大的效率考量，需要从整个社会角度看效率，而不是看单个个人。 经济学需要进行选择和对比。不光要看见看得见的，还要意识到看不见的。比如破窗理论，比如应当阻止机器人的发展，会让工人下岗之类的言论，我们需要看见看不见的，所以需要多正反两面去分析原因，比较和选择才能做出正确决定，理解利弊。同时经济学只关心那些事与愿违的事情，那些好心办坏事的事情，比如印度当年颁布眼镜蛇悬赏，谁杀的眼镜蛇多，就有奖，结果眼镜蛇不减反增，因为民众都私养眼镜蛇赚钱了。 小结 经济规律是普遍存在，有人的地方就有江湖。而是否有真正的公平，背后又是整个社会的效率的考量，我们如何做出正确的决策，需要透彻的辩证的看问题，看见看不见的。这第一节课是高尾建领，用讲故事的方法，理解一些本质的经济学概念，同时一些思路也开阔了思维。也欢迎微信公众号 “YunShell”，期待更多交流。 （全文完）","categories":[],"tags":[{"name":"北大经济学","slug":"北大经济学","permalink":"https://www.liuyun.fun/tags/北大经济学/"}]},{"title":"博文样式测试","slug":"test","date":"2018-02-27T12:30:33.000Z","updated":"2018-04-06T13:54:25.739Z","comments":true,"path":"2018/02/27/test/","link":"","permalink":"https://www.liuyun.fun/2018/02/27/test/","excerpt":"这里是为了测试Hexo Markdown 的效果","text":"这里是为了测试Hexo Markdown 的效果 这是一级标题这是二级标题这是三级标题这是四级标题图片引用 测试 代码测试 1234# pythondef fibc(n): assert isinstance(n, int) and n &gt;= 0 return fibc(n - 1) + fibc(n - 2) if n &gt; 2 else n 引用测试 这是一个引用 数学公式测试 $x=\\dfrac{ -b \\pm \\sqrt{b^2 - 4ac}} {2a}$ 表格测试 one tow three one one one one one one one one one 序列 item 测试 test one test two test three 插入音乐测试 版权测试","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuyun.fun/tags/Hexo/"},{"name":"Test","slug":"Test","permalink":"https://www.liuyun.fun/tags/Test/"}]},{"title":"Hexo+GitHub 快速搭建个人博客之二","slug":"Hexo+GitHub快速搭建个人博客之二","date":"2018-02-27T12:25:33.000Z","updated":"2018-04-06T11:46:41.133Z","comments":true,"path":"2018/02/27/Hexo+GitHub快速搭建个人博客之二/","link":"","permalink":"https://www.liuyun.fun/2018/02/27/Hexo+GitHub快速搭建个人博客之二/","excerpt":"在上一篇 Hexo+GitHub 快速搭建个人博客之一 中，介绍了如何使用 GitHub Pages 和 Hexo 搭建一个博客，","text":"在上一篇 Hexo+GitHub 快速搭建个人博客之一 中，介绍了如何使用 GitHub Pages 和 Hexo 搭建一个博客， 但是还没有绑定个人域名，如果你没有个人域名，那就要去购买一个了，这也是唯一一个需要花钱的地方，当然最低只需要花费2块钱就可以了，这个接下来会谈到具体的操作。 另外，本篇还会顺带讲解一下，如何将博客同时部署在 Coding 上。Coding.net 是提供类似于 GitHub 服务的国内网站，好处在于访问速度快很多，同时一样提供了好用的 Coding Pages 功能，用于托管个人博客服务。后面会讲解到 Hexo 如何同时部署到 GitHub Pages 和 Coding Pages，其实类似于 GitHub Pages 的操作。 下面将按照以下顺序进行动手操作 GitHub Pages 绑定个人域名 阿里云购买域名 将域名映射到 GitHub Pages 上 Hexo 同时部署博客到 GitHub Pages 和 Coding Pages 上 GitHub Pages 绑定个人域名阿里云购买域名因为我在阿里云购买了域名，所以这里以阿里云为例。当然也可以在其他地方购买，比如腾讯云。进入阿里云官网，找到 产品/域名与网站 ，点击进入，如果没有阿里云账号，需要先注册，如下图所示。 此时你可以看到各个后缀的域名了，有 .com .top 之类的，可以看到 .top 的域名最低只需要2块钱就可以，购买前先查询一下你的域名是否已被注册了，购买流程就不赘述。购买完毕后，域名需要实名认证，这个过程大概一至两天就可以通过了，之后这个域名就是你属于你个人专有了。 将域名映射到GitHub Pages上这步的目的是，当我们在浏览器中直接输入我们刚才购买的域名（比如我的 www.liuyun.fun），就可以直接跳转到我们部署到 GitHub Pages 上的博客网站，而无须输入类似 username.github.io 这样不好记的网址了。那么要如何操作呢？在上篇中，我们已经能通过 username.github.io 的网址来访问托管的博客了，为了达到刚才的目的，我们需要做的是，建立个人域名与 username.github.io 的映射关系，要完成这个映射关系，需要按照以下几个步骤进行操作。 获取你 github.io 的 IP 地址通过 Ping 你的github.io 这个网址，如下图所示 域名服务商进行域名解析我这里是阿里云的后台管理界面，进入到 云服务 DNS 界面，点击 解析设置 然后点击添加 添加解析 在弹出的界面中，选择记录类型为 A 类，意思是该域名的地址会跳转到我们设定的目的地，记录值方框填写刚才的 Ping 出的 IP 地址。这里我们添加两个 一个是 www，一个是 @ 添加完毕后，结果是这样的 GitHub Pages 设定进入到你自己的 GitHub Pages 项目，我这里的是 cloudy-liu.github.io ，进入该项目的 Settings ，向下拖动到 GitHub Pages 位置，目前你看到的是该网站 publish 到 https://cloudy-liu.github.io我们找到 Custom domain 进行自定义域名绑定，这里输入你购买的自定义域名，我这里是 www.liuyun.fun ，如下图所示。 保存完毕后，它 publish 的网址就更改为你刚才修改过的域名地址了，需要注意的是，刚才我们的动作，其实在 GitHub Pages 仓库中添加了一个 CNAME 的文件，该文件内容就是保存自定义域名的地址，这也就是，很多人也可以通过添加 CNAME 文件来绑定域名，其实这是一回事，只不过现在 Github 直接支持绑定自定义域名了，就不同在 push 代码了。需要注意的是，你每次更新文章时，会重新 clean 一次，因此需要将 CNAME 文件加入到你Hexo source 中，这样确保每次可以 push 到 github 仓库中, 了解更多 此时，你在浏览器中输入你自己的域名网址，就可以直接跳转到 Github Pages 的个人博客了，至此，个人博客的就绑定完毕了。 同时部署博客 Coding Pages 上这步其实是个备选题，如果你对博客的访问速度有需求，那么就可以考虑同时在部署博客到 Coding 上，毕竟国内的服务器速度要快。 开启 Coding Pages 的步骤其实和 GitHub Pages 大同小异，对任何未知的事情，我首先会选择查看官网资料，因为这是最权威的，官网资料未能覆盖到，再去 google 找。针对使用 Coding Pages ，它们官网说明的非常清楚，只需要照着做就好了，没什么困难。 注册一个 Coding 账号需要提醒的是，为了一致性，可以将 Coding 的账号邮箱设定和 Github 一样，这样一同部署就方便多了。 开启 Pages 服务官网已经讲解非常清楚，照做就好， https://coding.net/pages/ 在 Coding 网站， 绑定 ssh可以复用之前在 GitHub 绑定已经生成好的 ssh 的内容。绑定好后，在通过以下命令，检查一下 1$ ssh -T git@git.coding.net 增加部署到coding 网站修改 Hexo 的 _config.yml 文件 123456deploy: type: git repository: github: git@github.com:cloudy-liu/cloudy-liu.github.io.git coding: git@git.coding.net:cloudy-liu/cloudy-liu.coding.me.git branch: master 接下来，就可以使用 hexo d 部署到新博文到 Github 和 Coding ，当然这里 Coding 还是需要通过 Coding Pages 的域名直接访问，比如我的是 cloudy-liu.coding.me 访问刚才更新的博客内容。 小结本篇讲解了 Github Pages 如何绑定个人域名，以后就可以通过个人域名直接访问博客，同时顺带提了一下同时将博客部署到 Coding 中的几个步骤，希望对你有帮助。 (全文完） 相关链接： Hexo+GitHub 快速搭建个人博客之一","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuyun.fun/tags/Hexo/"},{"name":"github","slug":"github","permalink":"https://www.liuyun.fun/tags/github/"},{"name":"博客","slug":"博客","permalink":"https://www.liuyun.fun/tags/博客/"},{"name":"独立域名","slug":"独立域名","permalink":"https://www.liuyun.fun/tags/独立域名/"}]},{"title":"Hexo+GitHub 快速搭建个人博客之一","slug":"Hexo+GitHub快速搭建个人博客之一","date":"2018-02-26T12:25:33.000Z","updated":"2018-04-06T14:54:58.660Z","comments":true,"path":"2018/02/26/Hexo+GitHub快速搭建个人博客之一/","link":"","permalink":"https://www.liuyun.fun/2018/02/26/Hexo+GitHub快速搭建个人博客之一/","excerpt":"你可能听过一句话，叫做输出倒逼输入 ，","text":"你可能听过一句话，叫做输出倒逼输入 ， 如果你能把某个主题的写出来，并且别人还能够看得懂，那么说明你真的掌握了这个事情，写博客既可以方便分享，又可以作为自己日后查阅复盘的记录，一举多得。对我而言，除了学习，建立个人的连接渠道之外，练习把事情精炼的说清楚是最重要的目的。至于为什么要建立个人博客，可以看看这个知乎贴子的讨论。 好了，现在我告诉你只需最低花费 2 块钱就可以拥有一个属于个人域名的博客，你要不要。我这里使用的是 Hexo + GitHub Pages 的搭建方式。 Hexo 是一个快速，简单，强大的静态博客框架，支持 Markdown ，插件众多，部署快速，安装也非常友好，这就使得本地部署一个博客非常简单，但是我们需要别人也能够访问我们的博客，所以需要一台服务器，但是这需要花钱购买。 不过为了免费，我们可以使用 GitHub Pages 或是 Coding Pages 提供的托管服务， GitHub Pages 是用来为项目作展示的，也可以用来作为托管博客，这样两者结合就可以搭建出一个免费的博客网站，当然目前它的域名还是Github 项目专有域名，我们还需要有个人域名，这就是唯一需要花钱的地方，当然花2块钱，你就可以租一个域名一年，有了个人域名之后，在将其解析到GitHub Pages 网址上，以后就可以通过你的个人域名直接访问博客了，接下来，我们就开始动手搭建。 我的本机环境以及此次需要安装的软件如下 windows 7 ,64 位 Node.js Cmder Windows 超赞的终端 Cmder如果你在 Windows 上经常使用控制台的话，你一定会对 Windows 自带的 cmd.exe 深恶痛绝，漆黑的背景，看久了眼睛难受，无法窗口多开，多任务处理难受。cmder 就是 windows 控制台终端的福音，有了它，你就可以享受漂亮可自定义的 UI 界面，免安装，下载解压即用，使用完整版，还整合了 Git ，linux 下大部分命令也可以直接使用，比如 ls grep之类的，一个 Cmder 全搞定，于是我就把 Git Bash 给卸载了。 官网 下载完整版，然后解压，找到 cmder.exe 双击即可启动，以后我们就用它作为默认的终端，若 GitHub release 下载很慢，可以先去下载 freedownloadmanager ，这个下载 GitHub release 软件超快的。以后我们的命令都是在 cmder.exe中下的。 创建 GitHub Pages注册 GitHub 账号注册GitHub 账号的步骤，我就不贴了，去官网注册即可 cmder 终端初始 gitGitHub 是通过 git 进行操作的，它是一个分布式的版本控制系统，现在大部分开源软件都是由 Git 作为版本控制系统。所以之前，我们需要做一次全局的账号和邮箱的设定，用户名与邮箱和GitHub 账号注册时一致。 12$ git config --global user.name cloudy-liu$ git config --global user.email cloudy-liuu@gmail.com ssh 密钥绑定这步目的是为安全性验证。 在cmder 终端中输入以下命令产生 ssh 密钥，邮箱为GitHub 注册邮箱，有提示的，可一路回车键 1ssh-keygen -t rsa -C &quot;cloudy-liuu@gmail.com&quot; 进入到GitHub 网站中， Settings 左边栏SSH and GPG keys New SSh Key ，将刚才产生的公钥内容(C:\\Users\\Administrator\\.ssh\\id_rsa.pub) 粘贴进去即可。 cmder 中测试。输入以下命令，遇到确认信息，输入 yes ，成功如下所 123456λ ssh -T git@github.comThe authenticity of host &apos;github.com (13.229.188.59)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,13.229.188.59&apos; (RSA) to the list of known hosts.Hi cloudy-liu! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 创建github.io项目GitHub Pages 是通过创建一个名为 username.github.io 的项目达成的，每个账号只能创建一个，可以参照官网(https://pages.github.com/）操作 登入GitHub 账号 新建一个仓库。命名为username.github.io ，参看以下我的创建，勾选一下初始化 README 文件 创建成功后，该 Pages 就可以使用了，可以在 Settings GitHub Pages 中看到 Publish 了 此时任何人都可以通过浏览器打开访问上述网址了，查看内容了，当然目前这里只有一个 README文件 Hexo 搭建并部署博客下载 Node.jsHexo 是使用Node.js开发的，所以为了安装它，我们需要先安装 Node.js工具。去官网 下载安装最新版本的，安装就一路 next 即可，最后它会被加入到系统环境 path 中。 输入以下命令，查看是否安装成功 123C:\\Users\\Administratorλ node -vv8.9.4 安装 HexoNode.js 安装好以后，同时为我们装好了 npm 工具， 这是一个包管理工具，通过它我们可以下载各种插件，cmder.exe 中输入以下命令进行安装，查看是否安装成功可以输入 hexo -v 命令 ，至此 Hexo 就安装好了。 123456789101112 C:\\Users\\Administratorλ npm install hexo-cli -gC:\\Users\\Administrator\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\Admi...//省略+ hexo-cli@1.0.4updated 5 packages in 53.458sC:\\Users\\Administratorλ hexo -vhexo-cli: 1.0.4..//省略tz: 2017b 创建本地博客框架Hexo 安装好后，我们就可以轻松的开始创建博客了，常用的就几条命令。 初始化博客。用来初始一个博客系统，我们新建一个目录 blog，并且在 cmder中进入到该目录，执行初始化hexo init命令。 123456789E:\\blogλ hexo initINFO Cloning hexo-starter to E:\\blogCloning into &apos;E:\\blog&apos;...remote: Counting objects: 62, done.remote: Total 62 (delta 0), reused 0 (delta 0), pack-reused 62...added 338 packages in 69.358sINFO Start blogging with Hexo! 查看文件目录结构。初始化后，它的文件结构如下。其中 source/_posts 文件件，这个就是博客的内容，我们以后可以在这个目录新建 .md 文件，就可以了。初始状态下有个默认的hello-world.md 文件。 本地部署。 通过 hexo g hexo s 就可以查看了，然后在浏览器中输入 http://localhost:4000/ 就可以查看刚才本地部署的博客，至此本地博客系统已经成功架起来了，按下ctrl+c 终止，接下来，我们将此博客部署到 GitHub Pages 上去。 部署博客到 GitHub Pages上Hexo 中可以通过修改配置文件，来指定需要部署到哪里去，它使用的是 yaml格式文件，对格式很严格，记住冒号后需要加一个空格。 修改 _config.yaml 文件。这个文件可以修改标题，作者等信息，拉到最下面是部署的目的地，按照如下格式设定，我的部署如下 12345deploy: type: git repository: github: git@github.com:cloudy-liu/cloudy-liu.github.io.git branch: master 安装 Hexo git 部署插件，让 Hexo知道通过什么类型部署，这里是 git 12E:\\blogλ npm install hexo-deployer-git --save 开始部署到 GitHub Pages，通过如下命令 hexo clean hexo g hexo d 12345678910111213141516171819E:\\blogλ hexo cleanINFO Deleted database.INFO Deleted public folder.E:\\blogλ hexo gINFO Start processing...INFO 28 files generated in 641 msE:\\blogλ hexo dINFO Deploying: gitINFO Setting up Git deployment.......To git@github.com:lynnbest/lynnbest.github.io.git + bbfcc20...08c6344 HEAD -&gt; master (forced update)INFO Deploy done: git 浏览器打开 https://cloudy-liu.github.io/ ，就可以看到部署到结果。 至此，别人就可以通过类似 https://cloudy-liu.github.io 方式访问你的博客了。 小结本文详细记录了如何使用Hexo 结合 GitHub Pages 快速搭建个人博客，同时推荐了一个 Windows 超好用的终端 Cmder ，如果觉得本文对你有用，那就一个转发或者一个赞吧。同时欢迎关注微信公众号 “YunShell”。 （全文完）","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.liuyun.fun/tags/Hexo/"},{"name":"github","slug":"github","permalink":"https://www.liuyun.fun/tags/github/"},{"name":"博客","slug":"博客","permalink":"https://www.liuyun.fun/tags/博客/"}]}]