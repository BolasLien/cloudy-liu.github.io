{"pages":[],"posts":[{"title":"Hexo+GitHub 快速搭建个人博客之一","text":"你可能听过一句话，叫做输出倒逼输入 ， 如果你能把某个主题的写出来，并且别人还能够看得懂，那么说明你真的掌握了这个事情，写博客既可以方便分享，又可以作为自己日后查阅复盘的记录，一举多得。对我而言，除了学习，建立个人的连接渠道之外，练习把事情精炼的说清楚是最重要的目的。至于为什么要建立个人博客，可以看看这个知乎贴子的讨论。 好了，现在我告诉你只需最低花费 2 块钱就可以拥有一个属于个人域名的博客，你要不要。我这里使用的是 Hexo + GitHub Pages 的搭建方式。 Hexo 是一个快速，简单，强大的静态博客框架，支持 Markdown ，插件众多，部署快速，安装也非常友好，这就使得本地部署一个博客非常简单，但是我们需要别人也能够访问我们的博客，所以需要一台服务器，但是这需要花钱购买。 不过为了免费，我们可以使用 GitHub Pages 或是 Coding Pages 提供的托管服务， GitHub Pages 是用来为项目作展示的，也可以用来作为托管博客，这样两者结合就可以搭建出一个免费的博客网站，当然目前它的域名还是Github 项目专有域名，我们还需要有个人域名，这就是唯一需要花钱的地方，当然花2块钱，你就可以租一个域名一年，有了个人域名之后，在将其解析到GitHub Pages 网址上，以后就可以通过你的个人域名直接访问博客了，接下来，我们就开始动手搭建。 我的本机环境以及此次需要安装的软件如下 windows 7 ,64 位 Node.js Cmder Windows 超赞的终端 Cmder如果你在 Windows 上经常使用控制台的话，你一定会对 Windows 自带的 cmd.exe 深恶痛绝，漆黑的背景，看久了眼睛难受，无法窗口多开，多任务处理难受。cmder 就是 windows 控制台终端的福音，有了它，你就可以享受漂亮可自定义的 UI 界面，免安装，下载解压即用，使用完整版，还整合了 Git ，linux 下大部分命令也可以直接使用，比如 ls grep之类的，一个 Cmder 全搞定，于是我就把 Git Bash 给卸载了。 官网 下载完整版，然后解压，找到 cmder.exe 双击即可启动，以后我们就用它作为默认的终端，若 GitHub release 下载很慢，可以先去下载 freedownloadmanager ，这个下载 GitHub release 软件超快的。以后我们的命令都是在 cmder.exe中下的。 创建 GitHub Pages注册 GitHub 账号注册GitHub 账号的步骤，我就不贴了，去官网注册即可 cmder 终端初始 gitGitHub 是通过 git 进行操作的，它是一个分布式的版本控制系统，现在大部分开源软件都是由 Git 作为版本控制系统。所以之前，我们需要做一次全局的账号和邮箱的设定，用户名与邮箱和GitHub 账号注册时一致。 12$ git config --global user.name cloudy-liu$ git config --global user.email cloudy-liuu@gmail.com ssh 密钥绑定这步目的是为安全性验证。 在cmder 终端中输入以下命令产生 ssh 密钥，邮箱为GitHub 注册邮箱，有提示的，可一路回车键 1ssh-keygen -t rsa -C &quot;cloudy-liuu@gmail.com&quot; 进入到GitHub 网站中， Settings 左边栏SSH and GPG keys New SSh Key ，将刚才产生的公钥内容(C:\\Users\\Administrator\\.ssh\\id_rsa.pub) 粘贴进去即可。 cmder 中测试。输入以下命令，遇到确认信息，输入 yes ，成功如下所 123456λ ssh -T git@github.comThe authenticity of host &apos;github.com (13.229.188.59)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,13.229.188.59&apos; (RSA) to the list of known hosts.Hi cloudy-liu! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 创建github.io项目GitHub Pages 是通过创建一个名为 username.github.io 的项目达成的，每个账号只能创建一个，可以参照官网(https://pages.github.com/）操作 登入GitHub 账号 新建一个仓库。命名为username.github.io ，参看以下我的创建，勾选一下初始化 README 文件 创建成功后，该 Pages 就可以使用了，可以在 Settings GitHub Pages 中看到 Publish 了 此时任何人都可以通过浏览器打开访问上述网址了，查看内容了，当然目前这里只有一个 README文件 Hexo 搭建并部署博客下载 Node.jsHexo 是使用Node.js开发的，所以为了安装它，我们需要先安装 Node.js工具。去官网 下载安装最新版本的，安装就一路 next 即可，最后它会被加入到系统环境 path 中。 输入以下命令，查看是否安装成功 123C:\\Users\\Administratorλ node -vv8.9.4 安装 HexoNode.js 安装好以后，同时为我们装好了 npm 工具， 这是一个包管理工具，通过它我们可以下载各种插件，cmder.exe 中输入以下命令进行安装，查看是否安装成功可以输入 hexo -v 命令 ，至此 Hexo 就安装好了。 123456789101112 C:\\Users\\Administratorλ npm install hexo-cli -gC:\\Users\\Administrator\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\Admi...//省略+ hexo-cli@1.0.4updated 5 packages in 53.458sC:\\Users\\Administratorλ hexo -vhexo-cli: 1.0.4..//省略tz: 2017b 创建本地博客框架Hexo 安装好后，我们就可以轻松的开始创建博客了，常用的就几条命令。 初始化博客。用来初始一个博客系统，我们新建一个目录 blog，并且在 cmder中进入到该目录，执行初始化hexo init命令。 123456789E:\\blogλ hexo initINFO Cloning hexo-starter to E:\\blogCloning into &apos;E:\\blog&apos;...remote: Counting objects: 62, done.remote: Total 62 (delta 0), reused 0 (delta 0), pack-reused 62...added 338 packages in 69.358sINFO Start blogging with Hexo! 查看文件目录结构。初始化后，它的文件结构如下。其中 source/_posts 文件件，这个就是博客的内容，我们以后可以在这个目录新建 .md 文件，就可以了。初始状态下有个默认的hello-world.md 文件。 本地部署。 通过 hexo g hexo s 就可以查看了，然后在浏览器中输入 http://localhost:4000/ 就可以查看刚才本地部署的博客，至此本地博客系统已经成功架起来了，按下ctrl+c 终止，接下来，我们将此博客部署到 GitHub Pages 上去。 部署博客到 GitHub Pages上Hexo 中可以通过修改配置文件，来指定需要部署到哪里去，它使用的是 yaml格式文件，对格式很严格，记住冒号后需要加一个空格。 修改 _config.yaml 文件。这个文件可以修改标题，作者等信息，拉到最下面是部署的目的地，按照如下格式设定，我的部署如下 12345deploy: type: git repository: github: git@github.com:cloudy-liu/cloudy-liu.github.io.git branch: master 安装 Hexo git 部署插件，让 Hexo知道通过什么类型部署，这里是 git 12E:\\blogλ npm install hexo-deployer-git --save 开始部署到 GitHub Pages，通过如下命令 hexo clean hexo g hexo d 12345678910111213141516171819E:\\blogλ hexo cleanINFO Deleted database.INFO Deleted public folder.E:\\blogλ hexo gINFO Start processing...INFO 28 files generated in 641 msE:\\blogλ hexo dINFO Deploying: gitINFO Setting up Git deployment.......To git@github.com:lynnbest/lynnbest.github.io.git + bbfcc20...08c6344 HEAD -&gt; master (forced update)INFO Deploy done: git 浏览器打开 https://cloudy-liu.github.io/ ，就可以看到部署到结果。 至此，别人就可以通过类似 https://cloudy-liu.github.io 方式访问你的博客了。 小结本文详细记录了如何使用Hexo 结合 GitHub Pages 快速搭建个人博客，同时推荐了一个 Windows 超好用的终端 Cmder ，如果觉得本文对你有用，那就一个转发或者一个赞吧。同时欢迎关注微信公众号 “YunShell”。 （全文完）","link":"/2018/02/26/Hexo+GitHub快速搭建个人博客之一/"},{"title":"Hexo yilia 主题一揽子使用方案","text":"在用 Hexo 搭建完毕后，接着就寻找主题了，对比了几个主题 ，发现这个yilia 主题比较干净，简洁，于是就选了这个主题，但是有些细节不太习惯，于是就研究调整了一下，就是现在这个博客的样子。 查看所有文件，提示缺失模块yilia 在首次使用时，点击所有文章 时，会出现模块找不到的错误，可按照提示操作即可注意一下，_config.yml 路径是指 根目录下的，而非 yilia 主题下的 config文件 配置图片资源 添加图片资源文件夹。 路径为 themes/yilia/source/下，可添加一个 assets 文件夹，里面存放图片资源即可 配置文件中直接引用即可。路径为 themes/yilia/_config.yml，找到如下即可 123456# 微信二维码图片weixin: /assets/img/wechat.png# 头像图片avatar: /assets/img/head.jpg# 网页图标favicon: /assets/img/head.jpg 文章如何显示摘要 问题。点击主页时，发现所有文章都是全文显示，不利于查找，可控制显示的字数 解决办法。 在你 MD 格式文章正文插入 &lt;!-- more --&gt;即可，只会显示它之前的，此后的就不显示，点击文章标题，全文阅读才可看到，同时注释掉以下 themes/yilia/_config.yml，重复 1# excerpt_link: more 效果 文章显示目录增加文章目录 TOC(table of content )，方便阅读文章, 在 themes/yilia/_config.ym中进行配置 toc: 2即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。 增加归档菜单修改 themes/yilia/_config.yml 123menu: 主页: / 归档: /archives/index.html 修改代码块样式默认的代码样式太刺眼了，调成稍微柔和一些的，这里是调成 Atom 风格，以下为两种方式都可以，推荐第一种直接修改编译好的文件，不然还需要重新build。 直接修改编译好的文件。路径为： theme\\yilia\\source\\main.0cf68a.css 修改代码背景色，搜索 .article-entry .highlight, 修改background后面的颜色 修改代码字体颜色 .article-entry .highlight .line 修改源文件重新build。上述资源对应源文件为 yilia\\source-src\\css\\highlight.scss，按照如下方式build 1234cd 到 yilia 目录下npm installnpm run devnpm run dist 增加不蒜子统计利用这个统计，可以知道你博客的访问量 安装不蒜子脚本在 themes\\yilia\\layout\\_partial\\after-footer.ejs最后添加 1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 添加统计网站访问量修改 themes\\yilia\\layout\\_partial\\footer.ejs，包括访客数和站点访问总量 12345# PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 单篇文章点击量 themes\\yilia\\layout\\_partial\\article.ejs中 在 &lt;%- partial('post/title', {class_name: 'article-title'}) %&gt; 插入如下代码 12345678910&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments){ %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt; &lt;% } %&gt; 添加来必力评论系统点击这个链接 查看 添加版权信息点击这个链接 查看 插入网易云音乐 登入网易云音乐网页版，选择一首歌，点击歌曲详情，点击生成外链播放器 复制外链代码，插入你需要编辑的 MD 格式文章里面，即可 百度/Google统计/SEO点击这个链接查看，这几项都是相同的 七牛云图床博客内容最麻烦的就是插入图片，我们可以使用七牛云提供的 10G 的免费存储空间，将图片上传上去，然后生成外链，使用 Markdown 的图片引用方法即可，这样文章就脱离了图片编辑，转为在线了。同样一份文章，你部署在 csdn 等其他网页时，直接复制粘贴即可。 上传图片到七牛云 注册，并完成支付宝实名认证，实名认证后有10G的免费空间，认证免费额度 添加文件。步骤为添加 对象存储, 新建一个存储空间，进入到该空间，点击 内容管理,点击上传文件 生成外链插入到文章中 使用 PicGo 自动生成外链但是这样通过 web点击上传按钮方式，太效率了，这里使用 PicGo 工具，完成拖动自动生成外链，感谢作者。 查看你的七牛密钥。登入七牛云查看密钥 个人面板 -&gt; 密钥管理 PicGo 配置七牛账户。然后就在上传图，拖动图片进去，即可生成外链，直接插入到文章中即可。 Demo测试修改配置后，输入以下三条命令即可部署 123hexo cleanhexo ghexo d 点击这里 查看博客正文的效果 以上希望对你所有帮助。 （全文完）","link":"/2018/04/07/Hexo_yilia_主题一揽子优化方案/"},{"title":"Hexo+GitHub 快速搭建个人博客之二","text":"在上一篇 Hexo+GitHub 快速搭建个人博客之一 中，介绍了如何使用 GitHub Pages 和 Hexo 搭建一个博客， 但是还没有绑定个人域名，如果你没有个人域名，那就要去购买一个了，这也是唯一一个需要花钱的地方，当然最低只需要花费2块钱就可以了，这个接下来会谈到具体的操作。 另外，本篇还会顺带讲解一下，如何将博客同时部署在 Coding 上。Coding.net 是提供类似于 GitHub 服务的国内网站，好处在于访问速度快很多，同时一样提供了好用的 Coding Pages 功能，用于托管个人博客服务。后面会讲解到 Hexo 如何同时部署到 GitHub Pages 和 Coding Pages，其实类似于 GitHub Pages 的操作。 下面将按照以下顺序进行动手操作 GitHub Pages 绑定个人域名 阿里云购买域名 将域名映射到 GitHub Pages 上 Hexo 同时部署博客到 GitHub Pages 和 Coding Pages 上 GitHub Pages 绑定个人域名阿里云购买域名因为我在阿里云购买了域名，所以这里以阿里云为例。当然也可以在其他地方购买，比如腾讯云。进入阿里云官网，找到 产品/域名与网站 ，点击进入，如果没有阿里云账号，需要先注册，如下图所示。 此时你可以看到各个后缀的域名了，有 .com .top 之类的，可以看到 .top 的域名最低只需要2块钱就可以，购买前先查询一下你的域名是否已被注册了，购买流程就不赘述。购买完毕后，域名需要实名认证，这个过程大概一至两天就可以通过了，之后这个域名就是你属于你个人专有了。 将域名映射到GitHub Pages上这步的目的是，当我们在浏览器中直接输入我们刚才购买的域名（比如我的 www.liuyun.fun），就可以直接跳转到我们部署到 GitHub Pages 上的博客网站，而无须输入类似 username.github.io 这样不好记的网址了。那么要如何操作呢？在上篇中，我们已经能通过 username.github.io 的网址来访问托管的博客了，为了达到刚才的目的，我们需要做的是，建立个人域名与 username.github.io 的映射关系，要完成这个映射关系，需要按照以下几个步骤进行操作。 获取你 github.io 的 IP 地址通过 Ping 你的github.io 这个网址，如下图所示 域名服务商进行域名解析我这里是阿里云的后台管理界面，进入到 云服务 DNS 界面，点击 解析设置 然后点击添加 添加解析 在弹出的界面中，选择记录类型为 A 类，意思是该域名的地址会跳转到我们设定的目的地，记录值方框填写刚才的 Ping 出的 IP 地址。这里我们添加两个 一个是 www，一个是 @ 添加完毕后，结果是这样的 GitHub Pages 设定进入到你自己的 GitHub Pages 项目，我这里的是 cloudy-liu.github.io ，进入该项目的 Settings ，向下拖动到 GitHub Pages 位置，目前你看到的是该网站 publish 到 https://cloudy-liu.github.io我们找到 Custom domain 进行自定义域名绑定，这里输入你购买的自定义域名，我这里是 www.liuyun.fun ，如下图所示。 保存完毕后，它 publish 的网址就更改为你刚才修改过的域名地址了，需要注意的是，刚才我们的动作，其实在 GitHub Pages 仓库中添加了一个 CNAME 的文件，该文件内容就是保存自定义域名的地址，这也就是，很多人也可以通过添加 CNAME 文件来绑定域名，其实这是一回事，只不过现在 Github 直接支持绑定自定义域名了，就不同在 push 代码了。需要注意的是，你每次更新文章时，会重新 clean 一次，因此需要将 CNAME 文件加入到你Hexo source 中，这样确保每次可以 push 到 github 仓库中, 了解更多 此时，你在浏览器中输入你自己的域名网址，就可以直接跳转到 Github Pages 的个人博客了，至此，个人博客的就绑定完毕了。 同时部署博客 Coding Pages 上这步其实是个备选题，如果你对博客的访问速度有需求，那么就可以考虑同时在部署博客到 Coding 上，毕竟国内的服务器速度要快。 开启 Coding Pages 的步骤其实和 GitHub Pages 大同小异，它们官网说明的非常清楚，只需要照着做就好了，没什么困难。 注册一个 Coding 账号需要提醒的是，为了一致性，可以将 Coding 的账号邮箱设定和 Github 一样，这样一同部署就方便多了。 开启 Pages 服务官网已经讲解非常清楚，照做就好， https://coding.net/pages/ 在 Coding 网站， 绑定 ssh可以复用之前在 GitHub 绑定已经生成好的 ssh 的内容。绑定好后，在通过以下命令，检查一下 1$ ssh -T git@git.coding.net 增加部署到coding 网站修改 Hexo 的 _config.yml 文件 123456deploy: type: git repository: github: git@github.com:cloudy-liu/cloudy-liu.github.io.git coding: git@git.coding.net:cloudy-liu/cloudy-liu.coding.me.git branch: master 接下来，就可以使用 hexo d 部署到新博文到 Github 和 Coding ，当然这里 Coding 还是需要通过 Coding Pages 的域名直接访问，比如我的是 cloudy-liu.coding.me 访问刚才更新的博客内容。 小结本篇讲解了 Github Pages 如何绑定个人域名，以后就可以通过个人域名直接访问博客，同时顺带提了一下同时将博客部署到 Coding 中的几个步骤，希望对你有帮助。 (全文完） 相关链接： Hexo+GitHub 快速搭建个人博客之一","link":"/2018/02/27/Hexo+GitHub快速搭建个人博客之二/"},{"title":"Hexo-yilia使用gitalk/gitment评论系统","text":"来必力总是显示异常，现在抽时间找些资料，将博客评论系统更换为 gitment/gitalk。 。最好两种都尝试之后，选择使用gitalk ，界面更加好看，配置也简单。下面就是两种配置的详细步骤。 Gitment 的原理是利用 github 上的 issue 系统，也就是你提的评论都会对应生成 issue。当然账户只能是通过 github 账号。这点跟来必力有点差，不过博客的受众大部分都是程序员，所以也可以接受。 Hexo-yilia gitment 配置yilia 主题默认是支持 gitments的，所以只需要进行配置。 注册 OAuth Application当别人评论你的文章时，会需要它是授权。点击 https://github.com/settings/applications/new 进行注册。注册界面如下。 注册成功后，会获取到 Client ID/scerct 。如下图所示，接下来就是将信息填入配置文件中。 配置 _config.yml 文件打开themes\\yilia\\_config.yml ,在如下位置填入正确的信息即可。 gitment_owner: 填写你的 github 账户名即可 gitment_repo: repo 名字为可新建一个repo 或者使用博客托管的 repo 都行。 client_id和client_secret : 就是上步骤中注册的获取的信息。 重新部署配置完毕后，重新部署，即可看到效果。 1hexo g -d 解决Valid Fail部署后，每次文章的评论都会需要初始化，但是试验是发现初始化失败，查找资料后，发现是 github issue 本身的规则限制（label 的长度最长为50），可参考Gitment评论功能接入踩坑教程 。 解决方法，将 github issue 的 id 改为按照日期方式。 文件位置：themes\\yilia\\layout\\_partial\\post\\gitment.ejs 1234ar gitment = new Gitment({ // id: &quot;&lt;%=url%&gt;&quot;, id: &apos;&lt;%= page.date %&gt;&apos;, owner: &apos;&lt;%=theme.gitment_owner%&gt;&apos;, 重新部署即可。 Hexo-yilia gitalk 配置gitalk 风格感觉更加好看，维护的也比较勤。具体的配置方法，请参考 Hexo主题yilia增加gitalk评论插件 。然后重新部署hexo d -g 生成之后的样式如下。 (完）","link":"/2018/07/14/Hexo更换为GitTalk评论系统/"},{"title":"基于Java 7/8 的 HashMap 源码解析","text":"本篇我们来看看数据结构中一个非常基础的应用，哈希表。 Java 7 的实现HashMap.java 基本原理讲解 什么是哈希表(hash table) 我们看下维基百科对哈希（hash) 的解释， 散列（英语：Hashing）是电脑科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表） 也就是说，哈希表就是用来快速查找用的，哈希函数（也称为散列函数）就是用来生成检索的索引（index)的。 内部数据结构架构 基本流程概述 默认table的初始大小为 16, 12132 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16144 static final float DEFAULT_LOAD_FACTOR = 0.75f; 源码剖析流程 文件路径 构造函数，默认初始化容量为 16，加载因子为0.75 123280 public HashMap() {281 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); 282 } 接着调用带参数的构造函数，初始化加载因子和 threshold 1234567891011121314250 public HashMap(int initialCapacity, float loadFactor) {251 if (initialCapacity &lt; 0)252 throw new IllegalArgumentException(\"Illegal initial capacity: \" +253 initialCapacity);254 if (initialCapacity &gt; MAXIMUM_CAPACITY)255 initialCapacity = MAXIMUM_CAPACITY;256 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))257 throw new IllegalArgumentException(\"Illegal load factor: \" +258 loadFactor);259 260 this.loadFactor = loadFactor;261 threshold = initialCapacity;262 init();//为空263 } put 函数 123456789101112131415161718192021222324490 public V put(K key, V value) {491 if (table == EMPTY_TABLE) { //初始化默认大小的table，表的大小为16，同时更新下次resize的阈值threhold=12,(大小*加载因子）492 inflateTable(threshold); 493 }494 if (key == null)//处理 Key=null case, HashMap 允许 key为null495 return putForNullKey(value);496 int hash = hash(key);//获取该key的 hash值497 int i = indexFor(hash, table.length);//获取该key映射对应的数组索引 //若key相同，则做value的更新操作，然后返回，否则就插入新的节点498 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {499 Object k;500 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {501 V oldValue = e.value;502 e.value = value;503 e.recordAccess(this);504 return oldValue;505 }506 }507 508 modCount++;509 addEntry(hash, key, value, i);//采用头部插入法，插入新的链表节点510 return null;511 } 12345678315 private void inflateTable(int toSize) {316 // Find a power of 2 &gt;= toSize,确保 capacity为最小的2的整数次幂317 int capacity = roundUpToPowerOf2(toSize);318 //增长阈值为容量*加载因子，首次的阈值为 16*0.75=12319 threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);320 table = new Entry[capacity];//初始化table，开始时大小为 16321 initHashSeedAsNeeded(capacity); //初始化 hash mask 值322 } 1234567891011121314151617181920212223242526272829303132333435881 void addEntry(int hash, K key, V value, int bucketIndex) { //若此时table的size 不小于阈值了且刚插入的这个值又冲突了，重新调整大小882 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) { // 将table数组大小扩容为2倍，数组大小发生变化，所以 hash,index都需重新计算一次883 resize(2 * table.length);884 hash = (null != key) ? hash(key) : 0;885 bucketIndex = indexFor(hash, table.length);886 }887 899 void createEntry(int hash, K key, V value, int bucketIndex) { //查找到位于table数组中位置的节点900 Entry&lt;K,V&gt; e = table[bucketIndex]; //采用头部插入法插入节点,也就是若每次发生冲突，则都将新的节点插入到链表首位901 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);902 size++;903 } 576 void resize(int newCapacity) { //获取旧table，以及数据容量大小577 Entry[] oldTable = table;578 int oldCapacity = oldTable.length;579 if (oldCapacity == MAXIMUM_CAPACITY) {580 threshold = Integer.MAX_VALUE;581 return;582 }583 //重新new了一个数组584 Entry[] newTable = new Entry[newCapacity]; //旧table到新table做数据迁移585 transfer(newTable, initHashSeedAsNeeded(newCapacity));586 table = newTable; //更新 threhold，比如初始化表的大小16，扩容2倍为32，,此时resize的阈值为 32*0.74=24.587 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);588 } 123456789101112131415593 void transfer(Entry[] newTable, boolean rehash) {594 int newCapacity = newTable.length;595 for (Entry&lt;K,V&gt; e : table) {596 while(null != e) {597 Entry&lt;K,V&gt; next = e.next;598 if (rehash) {599 e.hash = null == e.key ? 0 : hash(e.key);600 }601 int i = indexFor(e.hash, newCapacity);602 e.next = newTable[i];603 newTable[i] = e;604 e = next;605 }606 }607 } get方法 12345678418 public V get(Object key) { // key为null情况，单独处理419 if (key == null)420 return getForNullKey();421 Entry&lt;K,V&gt; entry = getEntry(key);422 423 return null == entry ? null : entry.getValue();424 } 获取Entry，查找到并且返回。 12345678910111213141516461 final Entry&lt;K,V&gt; getEntry(Object key) {462 if (size == 0) {463 return null;464 }465 466 int hash = (key == null) ? 0 : hash(key);467 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];468 e != null;469 e = e.next) {470 Object k;471 if (e.hash == hash &amp;&amp;472 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))473 return e;474 }475 return null;476 } Overview继承关系HashMap 继承于 AbstractMap 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { 实例源码分析123456789import java.util.HashMap;public class Test { public static void main(String[] args) { HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;(); hm.put(\"one\", 1); System.out.println(\"hm: \" + hm); }} HashMap源代码 构造函数初始化 加载因子 0.75 123public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted} put方法key 为 “one”, value 为 123public V put(K key, V value) { return putVal(hash(key), key, value, false, true);} 会用到内置方法 putVal ，首先会将 key 做 hash 计算，我们接着看下 hash()方法 12 调用 Key 对象的 hashCode()方法生成 hash值，对于整数，哈希值就是它自己，对于字符串，它的值如下，可以查看相应的 hashCode() 方法，结果就是得到 32位的 hash值。 $hash = s[0]31^{n-1} + s[1]31^{n-2}+…+s[n-1]$ 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; } Android的优化","link":"/2018/04/22/JavaHashMap源码解析/"},{"title":"leetcode20-括号匹配","text":"括号匹配习题 题目Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 12345Input: &quot;()&quot;Output: trueInput: &quot;([)]&quot;Output: false 思路题目说仅有各种左括号和右括号的组合。可以使用栈的数据结构，因为匹配的括号的话，一定是成对出现的，若将左括号一次压入栈，遇到匹配的右括号在弹出栈，则若是匹配的话，栈最后一定为空。 遍历字符串，当遇到左括号时候，将其压入栈中，当是右括号时，看是否栈为空，若是空则直接返回(“)”，否则在看是否和栈顶元素匹配，若匹配，则出栈，若不匹配则直接返回false。遍历完成后，若栈为空，则返回true，否则返回false。 Solution基于以上的解法 1234567891011121314151617181920public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char currentChar = s.charAt(i); if ((currentChar == '(' || currentChar == '[' || currentChar == '{')) { stack.push(currentChar); } else if (stack.isEmpty()) { return false; } else { Character top = stack.peek(); if ((top == '[' &amp;&amp; currentChar == ']') || (top == '{' &amp;&amp; currentChar == '}') || (top == '(' &amp;&amp; currentChar == ')')) { stack.pop(); } else { return false; } } } return stack.isEmpty();} 此题虽然AC了，但是看了 leetcode 讨论区，发现一个非常简洁的写法，它将其翻转过来，上面我们压入栈的是左括号，而他压入栈的是右括号，在遇到右括号时，弹出栈，判断是否弹出的栈顶元素就是当前扫描的右括号，若不是，则不是匹配的字串，返回false，最后遍历完成后，判断栈是否为空。代码简洁好多。 12345678910111213141516public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if (c == '(') { stack.push(')'); } else if (c == '[') { stack.push(']'); } else if (c == '{') { stack.push('}'); } else if (stack.isEmpty() || stack.pop() != c) {// consider opposite side, very smart return false; } } return stack.isEmpty();} 完整source code","link":"/2018/07/01/leetcode20/"},{"title":"Windows 运行 tensorboard 1.6","text":"本篇讲述一下 Windows 环境下如何运行 Tensorboard 可视化 graph. 环境 Windows 7 tensorflow 1.6/1.8 tensorlfow 1.6 在 windows 上通过 pip3 install tensorflow 安装，同时会顺带安装 tensorboard 工具，1.6 版本已经修改过了文件路径，具体的使用方式，参看如下例子。本机是1.8版本，1.6 也同样适用。 例子创建 model首先我们新建一个 test.py, 编写一个最简单的矩阵乘法，最后将其graph 保存下来，代码如下， 123456789101112131415import tensorflow as tfx = tf.constant([1, 2, 3, 4, 5, 6], shape=[2, 3], name=\"x\")w = tf.constant([1, 2, 3, 4, 5, 6], shape=[3, 2], name=\"w\")b = tf.constant([1, 2, 3, 4], shape=[2, 2], name=\"b\")y = tf.matmul(x, w)+b # 计算 y=x*w +b 的模型with tf.Session() as sess: rst = sess.run(y) print(\"rst:\", rst) tf.summary.FileWriter(\"log\", graph=sess.graph) # 保存graph 到 当前文件 log目录下&gt;&gt;&gt; 输出结果rst: [[23 30] [52 68]] 运行完毕后，会在文件的当前路径，创建一个 log 文件夹，里面存有 graph 的信息，我本地目录结构如下 1234-- tmp -- log --- events.out.tfevents.1527778757.PC007 -- test.py 使用 tensorboard 查看可视化图形因为安装了 tensorflow 后，tensorboard 是会自动安装，如何运行文件呢？在终端中运行。 ctrl + R -&gt; 输入cmd -&gt; 回车，进行终端。然后运行如下命令，最后启动一个本地服务器。如下图所示，其实运行的是 tensorboard包下 main.py 文件。格式为 py -3 xx/tensorboard/main.py --logdir=path path就是你在tensorflow 保存时的路径。 1py -3 C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\site-packages\\tensorboard\\main.py --logdir=D:/tmp/log 然后在 chrome 浏览器中输入终端出现的信息 http:cloudy:6066 ，回车即可看到图形了 遇到的错误 chrome 浏览器需要升级。刚开始时候，我chrome 浏览器啥都不可见，升级一下 chrome 浏览器 就好了，我目前的版本是 版本 67.0.3396.62（正式版本） （32 位）。","link":"/2018/05/31/Windows运行tensorboard1.8/"},{"title":"博文样式测试","text":"这里是为了测试Hexo Markdown 的效果 标题测试这是一级标题这是二级标题这是三级标题这是四级标题图片引用 代码样式test.py123def fibc(n): assert isinstance(n, int) and n &gt;= 0 return fibc(n - 1) + fibc(n - 2) if n &gt; 2 else n 引用 这是一个引用 数学公式$x=\\dfrac{ -b \\pm \\sqrt{b^2 - 4ac}} {2a}$ 表格测试 one tow three one one one one one one one one one 序列 test one test two test three 插入音乐测试 版权测试","link":"/2018/02/27/test/"},{"title":"七大排序算法总结(Java实现版)","text":"这节开始总结7种最常用的排序算法，先来看看最简单的冒泡算法。 所有完整源代码点击github 这里 查看。我们假设测试数据集为以下数组，要求按照从小到达的升序排列。 而排序的动图演示，可以参考 http://www.atool.org/sort.php 1234567891011121314public static void main(String[] args) { int[][] data = new int[][]{ new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},//逆序 new int[]{1, 2, 3, 4, 5, 6, 7},//正序 new int[]{1, 7, 3, 5, 0, 2, 4, 8, 6}};//随机 for (int i = 0; i &lt; data.length; i++) { System.out.println(\"before sort\"); BaseSort.printArray(data[i]); ... System.out.println(\"after sort\"); BaseSort.printArray(data[i]); } } 冒泡排序思路基于相邻比较和交换的方法。针对 n个数，一共会有 n-1 轮。每轮将确定一个值的最终位置，比如升序，那么每轮将会该轮中最大的数的位置确定。 Java 实现先实现交换的辅助函数 123456789public void swap(int[] a, int indexI, int indexJ) { if (a == null || indexI &gt;= a.length || indexJ &gt;= a.length) { System.out.println(\"a is null ,index out of bound\"); return; } int tmp = a[indexI]; a[indexI] = a[indexJ]; a[indexJ] = tmp;} 冒泡排序实现 1234567891011public void bubbleSort(int[] input) { int rightSide = input.length; while (rightSide - 1 &gt; 0) { // 控制比较次数，比较次数为 len-1 for (int i = 1; i &lt; rightSide; i++) { //每轮下两两比较 if (input[i - 1] &gt; input[i]) { swap(input, i - 1, i); } } --rightSide; }} 你可以看到，当测试集为正序时候，仍然需要$O(n^2)$ 的复杂度，其实每一轮遍历中，两两比较，若整个序列没有发生交换，其实排序就已经可以停止了，比如正序情况下，第一轮两两比较时，由于都是正序，所以一边遍历后没有任何交换，此时就需要停止了。若发生交换，则记录最后一个交换的位置，则该位置为下次交换遍历的终点位置。减少不必要的比较。优化的代码如下 1234567891011121314public void bubbleSortOpt(int[] input) { int rightSide = input.length; int lastCompareIndex = rightSide;//记录最后一个比较的右边界，同时充当哨兵，是否停止 while (lastCompareIndex &gt; 0) {//是否要停止 rightSide = lastCompareIndex; lastCompareIndex = 0; //若未发生交换，则会停止 for (int i = 1; i &lt; rightSide; i++) { if (input[i - 1] &gt; input[i]) { swap(input, i - 1, i); lastCompareIndex = i;//记录最后一个发生交换的位置，下次比较的右边界 } } }} 这样复杂度，在最好的情况下（已经有序），可以变为$O(n)$ 复杂度分析间复杂度 排序算法的时间复杂度在于交换和比较的次数，因此交换和比较次数的总和越小，那么时间复杂度越低，冒泡排序一个有 n -1 轮的遍历，每轮遍历中，比较次数依次为 n-1,n-2,…1 。因此比较次数的总和为 $sum=\\sum_{1}^{n-1}=1+2+…+n-1=\\dfrac{n(n-1)}{2}$ 为 $O(n^2)$ 最差情况下（逆序），那么比较一次，就要交换一次。因此总次数为 n(n-1) ，为 $O(n^2)$ ，而最好的情况下，已序的情况下，经过优化后的冒泡为 n-1 次完成，$O(n)$ ,因此平均复杂度为 $O(n^2)$ 。 空间复杂度 因为都是固定的几个局部变量，因此空间复杂度为 O(1) 稳定性 因为是基于比较，所以冒泡排序是稳定，所谓稳定性就是指相等的两个数 a,b，排序后，a,b的前后位置不变，若a在b前，则排序后仍是a在b前，否则称为不稳定。 选择排序思路选择排序也是生活中比较常见的一种思路。和冒泡相比，它减少了交换的次数，冒泡相邻的两个数比较，一旦符合交换条件，就会进行交换。选择排序则是一次性找到最后的index值，在一次性的交换。 Java 实现1234567891011121314public void selectSort(int[] data) {//升序排序 int len = data.length; for (int i = 0; i &lt; len; i++) { int minIndex = i; //初始化假定i为最小值的索引 for (int j = i + 1; j &lt; len; j++) {//从 i+1处，开始寻找最小值的索引 if (data[minIndex] &gt; data[j]) { minIndex = j; } } if (minIndex != i) { //比较一轮下来后，minIndex位置若发生变化，交换 swap(data, minIndex, i);//swap函数实现间完整代码中 } }} 复杂度分析时间复杂度 由于是逐一确定每个索引位置处最合适的值，因此最好的情况和最差情况，都需要进行比较, $Sum=\\sum_{i=1}^{n-1}=1+2+3+..+n-1=\\dfrac{n(n-1)}{2}$，因此复杂度均为为 $O(n^2)$ 空间复杂度 因为都是固定的几个局部变量，因此空间复杂度为 O(1) 稳定性 不稳定。举个例子分析，3,1,3, 2 ，第一趟时 index=0为3，逐一确定最小值的索引，所以此时2为最小的值，因此第一个3要与2交换，这样第一个3就在第二个3后面，破换了相等两个值之前的顺序了。因此是不稳定的。 直接插入排序思路直接插入排序基本思想是将一个数插入一个已经有序的数组中，默认有序的为index=0的第一个数，然后逐渐将第i个数插入[0~i-1] 这样有序的数组中。因此可以看出直接插入排序，在已经基本有序的数组中，排序效率是很高的。 Java实现1234567891011121314public void insertSort(int[] data) { int len = data.length; //思想：将一个数插入已经有序的数组中，刚开始有序的为index=0的一个数 for (int i = 1; i &lt; len; i++) { if (data[i] &lt; data[i - 1]) {//若不满足，则该值已经有序,无须插入 int tmp = data[i]; //保存 data[i]值，后面 data[i]位置要被填坑 int j; for (j = i - 1; j &gt;= 0 &amp;&amp; tmp &lt; data[j]; j--) {//逐一向前插入，数组移动 data[j + 1] = data[j]; } data[j + 1] = tmp;//j+1位置为需要插入的位置 } }} 复杂度分析时间复杂度 最好情况下，每次插入前的比较都不满足，所以遍历一遍就结束 ，复杂度为 $O(n)$ 最差情况下，从i=1处开始，每次都要发生数组移动，移动次数为 $1+2+3+…+n-1=\\dfrac{n(n-1)}{2}$ 比较次数也一样，因此复杂度为 $O(n^2)$ 空间复杂度 几个局部变量，复杂度为 $O(1)$ 稳定性 基于比较，因此能保持相等的两个数的相对位置，是稳定的。 希尔排序思路借助直接插入排序。基本思想是将整个数组分步逐渐变为基本有序，到全有序。首先确定step，就是将整个数组分组，比如 step=2。那么就是该数组 索引位置 [0,2,4,6,..] 的子序列做插入排序，这样子序列完成有序。接着在step=1.那么就是所有的数组在做插入排序。 Java实现123456789101112131415 public void shellSort(int[] data) { int len = data.length; for (int step = len / 2; step &gt; 0; step /= 2) {//将数组分为几次做插入排序 for (int i = step; i &lt; len; i++) {//step 为间隔 if (data[i - step] &gt; data[i]) {//和插入排序一样， int tmp = data[i]; int j; for (j = i - step; j &gt;= 0 &amp;&amp; tmp &lt; data[j]; j -= step) {//只不过 -1换成-step data[j + step] = data[j]; } data[j + step] = tmp; } } }} 复杂度分析时间复杂度 希尔排序是第一批突破 $O(n^2)$ 的算法，算法的复杂度跟 step 步长有关系。见维基百科 空间复杂度 几个局部变量，复杂度为 $O(1)$ 稳定性 由于是跳跃式的移动，因此是不稳定的。 归并排序思路归并的意思包含两层，一个是分治，一个是合并。思想是将一个待排序的数组，分为两个有序的数组，然后将这两个有序数组合并为一个。 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142 public void mergeSort(int[] data) { int len = data.length; int[] tmp = new int[len]; mergeSortImplementRecur(data, 0, len - 1, tmp); } //递归实现 private void mergeSortImplementRecur(int[] data, int firstIndex, int lastIndex, int[] tmp) { if (firstIndex &gt;= lastIndex) {//递归的截止条件 return; } int midIndex = (firstIndex + lastIndex) / 2; mergeSortImplementRecur(data, firstIndex, midIndex, tmp); mergeSortImplementRecur(data, midIndex + 1, lastIndex, tmp); mergeArray(data, firstIndex, midIndex, lastIndex, tmp); }//非递归实现，TODO private void mergeArray(int[] data, int firstIndex, int midIndex, int lastIndex, int[] tmp) { int i = firstIndex; int n = midIndex; int j = midIndex + 1; int m = lastIndex; int k = 0; while (i &lt;= n &amp;&amp; j &lt;= m) {//逐一比较，将小的放入到 tmp数组中 if (data[i] &lt; data[j]) { tmp[k++] = data[i++]; } else { tmp[k++] = data[j++]; } } while (i &lt;= n) {//两个数组长度不一致时 tmp[k++] = data[i++]; } while (j &lt;= m) { tmp[k++] = data[j++]; } for (i = 0; i &lt; k; i++) {//复制到tmp数组中 data[firstIndex + i] = tmp[i]; } } 复杂度分析时间复杂度 每次合并将两个有序的数组合并一起，需要遍历一次，因此复杂度为$O(n)$ ，而要合并多少次？由于二分，所以次数为 $log_2n$ 次，所以总的时间复杂度： $nlog_2n$ 。进一步可以到，不管是正序，逆序复杂度均一样，因此效率比较高。 空间复杂度 因为归并排序使用了一个同等规模的额外辅助数组，这个复杂度为 $O(n)$，采用递归调用的话，因为递归栈的深度为 $log_2n$，因此总的是$O(n+log_2n)$。若采用的是非递归，那么递归栈部分可以省略，效率更高，复杂度为 $O（n)$ 。因此优先使用的是非递归的实现。 稳定性 由于也是基本两两比较，因此也是稳定性的 堆排序TODO 快速排序思路“分治”+”填坑“法。基本思路为，选取一个基准值，比如index=0的值，然后唯一确定这个基准的位置，使得该值前面的数都小于它，后面的数都大于它，这样就唯一确定了这个基准值的位置。然后在分别进行递归操作，逐一逼近单一数组值。而在确定基准值时候，是采用两头法，假设基准值为index=0的值，先保存好基准值，然后先从右游标向左找起，若是升序排序，则一直找到比基准值小的位置，停住。然后将该值填入基准值的坑，然后在从左往右找大于基准值的位置，找到后，将该值插入右边出现的坑。直到左右游标相遇，则该值就是基准值的位置填入，这样一轮下来，就唯一确定基准值了。然后在递归左序列和右序列。 Java 实现12345678910111213141516171819202122232425262728 public void quickSort(int[] data, int start, int end) { if (start &gt;= end) { return; } int base = data[start];//start 位置为基准值 int i = start; int j = end; while (i &lt; j) { while (i &lt; j &amp;&amp; data[j] &gt;= base) {//从右往左找小于的位置 j j--; } if (i &lt; j) { data[i++] = data[j]; } while (i &lt; j &amp;&amp; data[i] &lt;= base) { //从左往右找大于基准值的i i++; } if (i &lt; j) { data[j--] = data[i]; } } if (i == j) {//此时i为基准值的索引 data[i] = base; } quickSort(data, start, i - 1);//递归调用左序列 quickSort(data, i + 1, end);// 递归调用右序列} 上面的实现是快排的基本实现，但是可以看出，有许多地方可以进行优化。 基准值改进 首先基准值的选择比较重要，假设基准值每次都是选取了最大或是最小，其实一轮下来，数据量只是减少了一个，假设每次基准值都是选择比较平均，都是中间的值，那么每轮下来，数据量都会减小一半。可以采用取首位，中间值三者的中值来作为基准值。 尾递归改进 由于快排是基于递归实现，所以数据量大的时候，会造成调用栈深度过大，因此改为尾递归调用 小数量时，退化为直接插入排序 所以优化后的快排为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void quickSortOpt(int[] data, int start, int end) { if (end - start &lt; MAX_SORT_NUMBER) {//优化1，小数据采用 直接插入法 insertSort(data, start, end); } else { while (start &lt; end) {//优化2,尾递归减少调用栈 int i = start; int j = end; //优化3。采用中值法，选择基准值 int mid = (start + end) / 2; if (data[start] &gt; data[end]) { swap(data, start, end); } if (data[mid] &gt; data[end]) { swap(data, mid, end); } if (data[mid] &gt; data[start]) { swap(data, mid, start); } int base = data[start]; while (i &lt; j) { while (i &lt; j &amp;&amp; data[j] &gt;= base) { j--; } if (i &lt; j) { data[i++] = data[j]; } while (i &lt; j &amp;&amp; data[i] &lt;= base) { i++; } if (i &lt; j) { data[j--] = data[i]; } } if (i == j) { data[i] = base; } quickSort(data, start, i - 1); start = i + 1;//优化2 尾递归 } } } private void insertSort(int[] data, int start, int end) { for (int i = start + 1; i &lt;= end; i++) { if (data[i - 1] &gt; data[i]) { int tmp = data[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; tmp &lt; data[j]; j--) { data[j + 1] = data[j]; } data[j + 1] = tmp; } } } 复杂度分析从实现来看，快排每次都需要遍历一次数组，$O(n)$ ，而最差的情况，每次分治后，都只减少一个数据，所以一共会有 n-1 次，所以此种情况下，时间复杂度为 $O(n^2)$ ，最好的情况下，是每次分治都减少一半的数据量，因此次数为 $O(logn)$ ，所以最好的情况是 $O(nlogn)$ ，空间复杂度为由于是递归调用，所以$O(logn)$ 同时又由于是跳跃的比较，所以是不稳定的。 总结 时间复杂度（最好） 时间复杂度（最差） 时间平均复杂度 空间复杂度 稳定性 冒泡排序 $O(n)$ O(n^2) $O(n^2)$ O(1) 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ O(1) 不稳定 直接插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ O(1) 稳定 希尔插入排序 $O(nlogn)$ 依据step 依据step O(1) 不稳定 归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ O(n) 稳定 快速排序 $O(nlogn)$ $O(n^2)$ $O(nlogn)$ $O(logn)$ 不稳定 Refs sort_wiki","link":"/2018/06/14/七大排序算法总结(Java实现版)/"},{"title":"从经济学思维出发","text":"司马迁在 &lt;货殖列传&gt; 中说 “天下熙熙，皆为利来，天下攘攘，皆为利往“，以前我觉得这句话未免太过现实，心中还是有多少抵触，难道社会不讲感情了吗？我一直很好奇现代社会是如何发展至今的，其背后的规律是什么，达尔文的进化论是否仍旧有效，现代商业化世界中各种让人头晕的名词是什么意思，商业的背后逻辑是什么？带着这些好奇，我开始利用闲暇时间，学习得到上薛兆丰老师的北大经济学，希望系统的学习经济学思维，进行一次认知和思维的升级。学习最好的方式是翻转式学习，就是将学习到的东西简洁有效的做输出，这是第一次输出。 开篇薛老师就讲了一个故事说明经济学是普遍存在的这个道理，讲的是二战的一个战俘营里的故事，战俘刚进战俘营时，大家还会相互有爱心，但是人毕竟有物质生活的基本需求，要生存，而生存的质量好坏，光靠爱心是不够的，一方无限给予，他就不能生存了，所以真正长久的还是需要靠商品和服务的交换，只有交换才能才是平衡，才能让整个群体生存下去。 同时战俘营的生活也有各种经济现象，有了交换，就需要货币作为流通，战俘营当然没有钱币这种东西，所以就用香烟替代，有个货币就有价格，比如面包能换几根香烟，都有明码标价，除了实物交换，还产生了其他”服务行业“，比如帮别人洗衣服，熨衣服等。既然商品有了价格，就会有价格的波动，比如红十字会是每周四和周日发面包，那什么时候面包是最紧缺的？是在派发面包的前一天，此时面包的价格是最贵的，因为大部分人是等不到发面包就吃完了，而一旦面包发了，那么面包的价格又降下来了。 同时有了货币就会有劣币驱逐良币的现象，他们会把好的香烟拆开，里面混进些头发丝之类的充数。也会有宏观经济的波动，比如通货紧缩和通货膨胀，比如每次战俘营旁边发生空袭的时候，战俘们觉得生命很可能就完了，还存那么多香烟干嘛，今朝有酒今朝醉，所以就开始吸平时不舍得的香烟，等到第二天发现安然无恙，此时香烟就紧缺了，又比如听说红十字会会送来一批香烟过来，所有的商品就会跟着涨价，但是后面被证实是假消息，这就是泡沫，商品又恢复到常规价格了。此外有人就有情绪，就会有舆论，会讨论交易是否道德。这些在生活随处可见的经济现象在战俘营也存在。 人处在社会之中，就要受到各种制度的约束，比如法律。那么这些制度定义的是什么？是为了公平吗？这里薛老师又讲了一个马粪案的故事，说原告和他的两个助手在街上捡马粪，忙会了一会儿，把马粪堆到一起后，就回去取车来拉，后来被告经过看到后，就问巡逻的人，这个是否有主人，巡逻的说不知道，被告就自己拉走了，撒到自己田里去了，后来原告回来看到，就和被告理论，最后打起了官司。 原告说这是他们付出劳动堆积起来的，所以马粪应该归他们，而被告说不对，马粪掉到地上，它就属于地上的一部分，这个地是公家的，所以不属于原告，原告只是改变了马粪的所在位置，并未改动过它的所有权，所以马粪不归原告所有。如果你是法官怎么判？这个案子本身并没有什么，最重要的是给后世留下什么样的指导意义，是鼓励人们靠劳动创造财富，还是鼓励人们只要没有做标记，就可以据为己有，以后的社会发展又会怎样。所以制度的建立是要指导未来社会和经济的发展，公平背后就是最大的效率考量，需要从整个社会角度看效率，而不是看单个个人。 经济学需要进行选择和对比。不光要看见看得见的，还要意识到看不见的。比如破窗理论，比如应当阻止机器人的发展，会让工人下岗之类的言论，我们需要看见看不见的，所以需要多正反两面去分析原因，比较和选择才能做出正确决定，理解利弊。同时经济学只关心那些事与愿违的事情，那些好心办坏事的事情，比如印度当年颁布眼镜蛇悬赏，谁杀的眼镜蛇多，就有奖，结果眼镜蛇不减反增，因为民众都私养眼镜蛇赚钱了。 小结 经济规律是普遍存在，有人的地方就有江湖。而是否有真正的公平，背后又是整个社会的效率的考量，我们如何做出正确的决策，需要透彻的辩证的看问题，看见看不见的。这第一节课是高尾建领，用讲故事的方法，理解一些本质的经济学概念，同时一些思路也开阔了思维。也欢迎微信公众号 “YunShell”，期待更多交流。 （全文完）","link":"/2018/03/11/从经济学思维出发_/"},{"title":"求取质数素数的几种方式","text":"质数/素数在数学上定义为只能被1或者自身整除的数。道德经中的宇宙观为，“道生一，一生二，二生三，三生万物”。 所以任何物质都是由几个基本元素组成合成新的事物，对于数学的数字似乎也是这样，在大的数字，也是由一些基本的数字相乘而得到，而这些基本的数字，就是质数。关于质数仍旧有很多问题未能解决，感兴趣的参见 质数 了解。 在程序设计中，质数判断是常见的问题，这里总结一下常见的几种方式。0,1默认不是质数。 定义法从定义本身出发，判断一个数n 是否为质数，除去1和本身，那就看它是否能被 2~n-1 中的数整除，若能整除则不是，则不能，则是。 1234567891011121314/** * Solution1：最基本的定义法 质数 他数整数 效率低 */public static boolean isPrimeSolution1(int n) { if (n == 0 || n == 1) { return false; } for (int i = 2; i &lt; n; i++) { if (n % i == 0) { return false; } } return true;} 当然效率是非常低的，对于很大的数，是要计算很久，因为毕竟要逐一进行整除判断 定义改进1(缩小范围)那么是否判断范围从 2~n-1呢？这里其实可以在继续缩短比较范围，范围为 $[2 ,\\sqrt{n}]$ 即可。为什么呢？因为假设一个数是合数（也就是非质数），一定是由其他两个数相乘得到，那么其中一个必然小于它的开根号数，另一个必然大于它的开根号数，这点可以从反证法判断，如果相乘的两个数都小于开方数，那么乘积必然小于该数，假设不成立。所以改进如下。 1234567891011121314151617/** * Solution2: 定义法改进 思路： 不必判断该数 是否能整除 2~n-1。可 * 小范围。2~sqrt(n)。因为若一个数是合数 * （也就是由其他两个数乘积得到），那么其中一个必然小于它的开方数，另一个必然大于（反证法证明， * 如果两个都小于开方数，那么乘积就会小于该数，不符合） */public static boolean isPrimeSolution2(int n) { if (n == 0 || n == 1) { return false; } for (int i = 2; i &lt;= Math.sqrt(n); i++) { if (n % i == 0) { return false; } } return true;} 定义改进2(再排除偶数）上面是从判断整除范围角度缩小，那其实从定义出发，能在删除一半的数-偶数，如果是偶数，肯定不是质数，因为偶数一定能被2整除，所以概述肯定不是质数，这就又删除一半的，只考虑奇数。 123456789101112131415public static boolean isPrimeSolution3(int n) { if (n == 0 || n == 1) { return false; } if (n &gt; 2 &amp;&amp; n % 2 == 0) {// 排除偶数 return false; } int sqrtValue = (int) Math.sqrt(n); for (int i = 3; i &lt;= sqrtValue; i += 2) {//奇数 if (n % i == 0) { return false; } } return true;} 筛选法通常可以利用筛选法，求出某个范围内的所有质数。它的原理依然利用质数的性质，不能是任何质数的倍数，逐一排除。其实看到偶数，其实就不是质数，因为2是质数，偶数一定能被2整除，所以偶数一定不是质数。它的思路为，假设求取20以内的质数。 先开辟一个容量为20的boolean 类型数组primeArray[20]，并全部初始化为 true。索引为该值，值为true,则表示该值为质数，false则不是，例如primeArray[0]=false. 则表示0不是质数 初始化0,1为非质数。从质数开始，删除该质数的所有的倍数 从2开始，逐一删除掉 它的倍数(2倍，3倍，4倍…) ，直到超过选定的数据范围 在从3开始，逐一删除掉它的倍数，重复以上 直到所有超过数据范围 123456789101112131415161718192021222324252627282930/*** * Solution3: 筛选法： * 思路：假定求取 20 以内的素数。那么先初始化一个30boolean 类型数组，都初始化为true, * 数组索引都对应该数字，里面的值表示是否是质数。如 primeArray[0]=false, 表示 0不是质数。 * 筛的原理为，逐一去掉倍数的值，也就是能整除的值。 * 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 * 0,1 索引处，初始化为 false. 从2开始 * 那么2的2倍，3倍，4倍..直到数值超出。筛选一次后，2,3,5,7,11,13,15,17,19 * 那么在接着3开始，3也是质数。3的2倍，3倍。。直到超过。筛选后，2,3,5,7,11,13,17,19 * 接着从索引为4，4不是质数，跳过，依次类推。 * * 这样可以存储指定大小的质数数组，查找就直接获取值 */public static boolean[] primeArray = new boolean[100];public static void initPrimeArray(int n) { Arrays.fill(primeArray, true); primeArray[0] = primeArray[1] = false; for (int i = 2; i &lt; n; i++) { if (primeArray[i]) { for (int j = 2; i * j &lt; primeArray.length; j++) { primeArray[i * j] = false; } } }}public static boolean isPrimeSolution3(int n) { return primeArray[n];} 完整的Java 测试工程见 github","link":"/2018/07/08/求取质数素数的几种方式/"},{"title":"尾递归简述","text":"在上一章节中的排序算法中，可以到递归调用是一种思路非常清晰，易于简化的方式，但是副作用就是调用栈的开销。 递归的开销一般计算机语言实现，方法调用都是放在栈帧中执行，这里以Java 为例，从java的内存模型来看，方法的调用是在 Java stack 中，也就是java 栈中，方法的嵌套会形成一个嵌套的调用栈，栈内主要存储的是方法的局部变量和方法参数，在该方法执行完毕后，该栈被销毁。但是栈总有一个深度的极限值，超过了该极限值，会发生栈溢出。所以在编码时候，为了效率，尽可能的要将递归转为迭代实现。 什么是尾递归从上面定义可看出，递归对方法栈的消耗，一大部分都是在局部变量和参数，假设可以节省局部变量，势必会减少栈的消耗。减少空间复杂度。尾递归的本质是将函数的临时返回值，变为函数的参数实现的。 举例与性能测试我们这里实现集中斐波那契数列，分析一下它的运行时间的消耗。 递归实现没什么好解释的，直接看代码 123456789public static long fibRecursion(int n) { if (n &lt; 0) { return 0; } if (n == 0 || n == 1) { return n; } return fibRecursion(n - 1) + fibRecursion(n - 2);} 时间的瓶颈主要在递归调用，非常多的重复的计算，造成性能差，时间复杂度为$O(n^2)$。空间复杂度 $O(logn)$,比如计算 F(5) -&gt; f(4),f(3) -&gt;f(3),f(2),f(2),f(1) -&gt; f(2),f(1),f(1),f(0) ，可以看到大量的重复计算。 尾递归尾递归其实算是一种迭代的方式，将结果放在参数位置，从而不产生局部变量。 1234567//尾递归实现public static long fibTailRecursion(int n, int fibResult, int fibPlusOne) { if (n == 0) { return fibResult; } return fibTailRecursion(n - 1, fibResult + fibPlusOne, fibResult);} 迭代实现从前往后计算，减少了重复，时间复杂度为 $O(n)$ 1234567891011121314151617181920//迭代实现public static long fibIter(int n) { if (n &lt; 0) { return 0; } if (n == 0 || n == 1) { return n; } long fibPlusOne = 1; long fibPlusTwo = 0; long rst = 0; for (int i = 1; i &lt; n; i++) { rst = fibPlusOne + fibPlusTwo; fibPlusTwo = fibPlusOne; fibPlusOne = rst; } return rst;} 性能对比。可以看出 迭代和尾递归效果差并不多，在40个数据量的时候。 12345678910111213141516171819202122232425262728293031 public static void main(String[] args) { int fibValue = 40; long start = System.currentTimeMillis(); for (int i = 0; i &lt; fibValue; i++) { try { fibRecursion(i); } catch (Exception e) { e.printStackTrace(); } } System.out.println(\"Recursion spend : \" + (System.currentTimeMillis() - start) + \" ms\"); start = System.currentTimeMillis(); for (int i = 0; i &lt; fibValue; i++) { fibTailRecursion(i, 0, 1); } System.out.println(\"tail Recursion spend : \" + (System.currentTimeMillis() - start) + \" ms\"); start = System.currentTimeMillis(); for (int i = 0; i &lt; fibValue; i++) { fibIter(i); } System.out.println(\"iter spend : \" + (System.currentTimeMillis() - start) + \" ms\"); }}/* outputRecursion spend : 1562 mstail Recursion spend : 0 msiter spend : 0 ms */","link":"/2018/06/22/尾递归简述/"},{"title":"Hexo博客图片链接失效问题解决","text":"博客中的图片失效很久了，一直没时间来处理。现在把解决过程整理了一下，供同样问题的人参考 失效原因因为我的博客图床是托管在七牛云存储上(个人免费10G)，但是目前七牛云提供的测试域名均只有 30天的试用期，过了试用期会被回收，导致图片链接失效。解决的方法就是按照七牛云的指导，绑定自定义域名，并且该域名必须要工信部备案，而这个备案过程至少要20+天，时间非常长，我这目的也仅仅是为博客做图床而已，因此不想去申请麻烦的备案。因此另谋出路。 需求整理 另找一个可简单使用的图床，不需要备案之类的 可一直存储图片 访问速度要还凑合 最后经过选择，使用 coding 项目作为图床，coding跟腾讯云开发者绑定后，项目数和速度都免费畅享，也就是项目可以一直开下去，下图就是升级之后的好处 图片转移 Step 新建 coding 项目，将之前博客中的图片都上传上去 我因为本地没有保存之前的图片了，这个可以在七牛云上申请工单处理，可延长你的测试域名期限，我的延长了3天，然后批量下载下来了。 上传完了图片后，随便点击一张图片，查看这个图片的完整链接 比如 这里：https://coding.net/u/cloudy-liu/p/BlogPicBed/git/blob/master/1.png，我们将其中的blob 替换成 raw ，然后在修改为 markdown的链接语法： ![](https://coding.net/u/cloudy-liu/p/BlogPicBed/git/raw/master/1.png) 就可以在 markdown 支持的文本中看到这张图片了 使用新的图片链接替换你原博文中的图片链接 因为用 markdown 写的博文，图片都是链接的形式，比如之前的博文图片链接都是七牛云域名的图片，如 ![](http://p5sfmckwy.bkt.clouddn.com/img/2_top_2_rmb.png)，现在仅需要替换为新的域名即可，因为图片的名字不用改，只需要修改之前的域名为 coding 新建项目上的域名即可，当然博文非常多，我这里写了简单的 python 脚本来一次性批量处理 replace_pic.py 代码如下 123456789101112131415161718192021222324252627282930313233343536# coding=utf-8import argparseimport osimport reOLD = \"http://xxx.clouddn.com/img/\" #修改为你原来图片地址NEW = \"https://xxx/git/raw/master/\" #修改为你coding项目图床地址def get_arg(): parser = argparse.ArgumentParser() parser.add_argument(\"-p\", \"--path\", type=str, dest=\"path\", help=\"blog article path\") args = parser.parse_args() path = args.path print(\"path: \", path) replace_path = path.replace(\"\\\\\", \"/\") print(\"replaced_path:\", replace_path) return replace_pathdef main(path): file_list = [os.path.abspath(os.path.join(root, file)) for root, _, files in os.walk(path) for file in files] print(file_list) print(\"start ..\") for f in file_list: content = \"\" with open(f, \"rb\") as fp: file_content = fp.read() content = re.sub(OLD, NEW, file_content) with open(f, \"wb\") as fp: fp.write(content)if __name__ == '__main__': main(get_arg()) 使用方式，-p 指定目录后，会将该目录下的所有文件，将旧的链接替换为新的链接 1python 路径/replace_pic.py -p 你博文的目录 修正后，在更新 hexo d -g 进行更新博客即可，图床即更换了","link":"/2019/05/23/Hexo博客图片链接失效问题解决/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"博客","slug":"博客","link":"/tags/博客/"},{"name":"yilia","slug":"yilia","link":"/tags/yilia/"},{"name":"独立域名","slug":"独立域名","link":"/tags/独立域名/"},{"name":"gitment","slug":"gitment","link":"/tags/gitment/"},{"name":"gitalk","slug":"gitalk","link":"/tags/gitalk/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"HashMap","slug":"HashMap","link":"/tags/HashMap/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/数据结构与算法/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"ML","slug":"ML","link":"/tags/ML/"},{"name":"Tensorflow","slug":"Tensorflow","link":"/tags/Tensorflow/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"查找","slug":"查找","link":"/tags/查找/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"北大经济学","slug":"北大经济学","link":"/tags/北大经济学/"},{"name":"七牛云","slug":"七牛云","link":"/tags/七牛云/"}],"categories":[]}