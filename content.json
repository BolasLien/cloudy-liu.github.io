{"pages":[{"title":"about","text":"关于博主 Android Framework Developer, Performance 不怎么更新的公众号(苦笑) 博客历史 2019/6/23, 主题迁移到 icarus 2018/2/16, 新建博客,采用 Hexo 框架，主题选择 yilia","link":"/about/index.html"}],"posts":[{"title":"Hexo+GitHub 快速搭建个人博客之一","text":"你可能听过一句话，叫做输出倒逼输入 ， 如果你能把某个主题的写出来，并且别人还能够看得懂，那么说明你真的掌握了这个事情，写博客既可以方便分享，又可以作为自己日后查阅复盘的记录，一举多得。对我而言，除了学习，建立个人的连接渠道之外，练习把事情精炼的说清楚是最重要的目的。至于为什么要建立个人博客，可以看看这个知乎贴子的讨论。 好了，现在我告诉你只需最低花费 2 块钱就可以拥有一个属于个人域名的博客，你要不要。我这里使用的是 Hexo + GitHub Pages 的搭建方式。 Hexo 是一个快速，简单，强大的静态博客框架，支持 Markdown ，插件众多，部署快速，安装也非常友好，这就使得本地部署一个博客非常简单，但是我们需要别人也能够访问我们的博客，所以需要一台服务器，但是这需要花钱购买。 不过为了免费，我们可以使用 GitHub Pages 或是 Coding Pages 提供的托管服务， GitHub Pages 是用来为项目作展示的，也可以用来作为托管博客，这样两者结合就可以搭建出一个免费的博客网站，当然目前它的域名还是Github 项目专有域名，我们还需要有个人域名，这就是唯一需要花钱的地方，当然花2块钱，你就可以租一个域名一年，有了个人域名之后，在将其解析到GitHub Pages 网址上，以后就可以通过你的个人域名直接访问博客了，接下来，我们就开始动手搭建。 我的本机环境以及此次需要安装的软件如下 windows 7 ,64 位 Node.js Cmder Windows 超赞的终端 Cmder如果你在 Windows 上经常使用控制台的话，你一定会对 Windows 自带的 cmd.exe 深恶痛绝，漆黑的背景，看久了眼睛难受，无法窗口多开，多任务处理难受。cmder 就是 windows 控制台终端的福音，有了它，你就可以享受漂亮可自定义的 UI 界面，免安装，下载解压即用，使用完整版，还整合了 Git ，linux 下大部分命令也可以直接使用，比如 ls grep之类的，一个 Cmder 全搞定，于是我就把 Git Bash 给卸载了。 官网 下载完整版，然后解压，找到 cmder.exe 双击即可启动，以后我们就用它作为默认的终端，若 GitHub release 下载很慢，可以先去下载 freedownloadmanager ，这个下载 GitHub release 软件超快的。以后我们的命令都是在 cmder.exe中下的。 创建 GitHub Pages注册 GitHub 账号注册GitHub 账号的步骤，我就不贴了，去官网注册即可 cmder 终端初始 gitGitHub 是通过 git 进行操作的，它是一个分布式的版本控制系统，现在大部分开源软件都是由 Git 作为版本控制系统。所以之前，我们需要做一次全局的账号和邮箱的设定，用户名与邮箱和GitHub 账号注册时一致。 12$ git config --global user.name cloudy-liu$ git config --global user.email cloudy-liuu@gmail.com ssh 密钥绑定这步目的是为安全性验证。 在cmder 终端中输入以下命令产生 ssh 密钥，邮箱为GitHub 注册邮箱，有提示的，可一路回车键 1ssh-keygen -t rsa -C &quot;cloudy-liuu@gmail.com&quot; 进入到GitHub 网站中， Settings 左边栏SSH and GPG keys New SSh Key ，将刚才产生的公钥内容(C:\\Users\\Administrator\\.ssh\\id_rsa.pub) 粘贴进去即可。 cmder 中测试。输入以下命令，遇到确认信息，输入 yes ，成功如下所 123456λ ssh -T git@github.comThe authenticity of host &apos;github.com (13.229.188.59)&apos; can&apos;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,13.229.188.59&apos; (RSA) to the list of known hosts.Hi cloudy-liu! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 创建github.io项目GitHub Pages 是通过创建一个名为 username.github.io 的项目达成的，每个账号只能创建一个，可以参照官网(https://pages.github.com/）操作 登入GitHub 账号 新建一个仓库。命名为username.github.io ，参看以下我的创建，勾选一下初始化 README 文件 创建成功后，该 Pages 就可以使用了，可以在 Settings GitHub Pages 中看到 Publish 了 此时任何人都可以通过浏览器打开访问上述网址了，查看内容了，当然目前这里只有一个 README文件 Hexo 搭建并部署博客下载 Node.jsHexo 是使用Node.js开发的，所以为了安装它，我们需要先安装 Node.js工具。去官网 下载安装最新版本的，安装就一路 next 即可，最后它会被加入到系统环境 path 中。 输入以下命令，查看是否安装成功 123C:\\Users\\Administratorλ node -vv8.9.4 安装 HexoNode.js 安装好以后，同时为我们装好了 npm 工具， 这是一个包管理工具，通过它我们可以下载各种插件，cmder.exe 中输入以下命令进行安装，查看是否安装成功可以输入 hexo -v 命令 ，至此 Hexo 就安装好了。 123456789101112 C:\\Users\\Administratorλ npm install hexo-cli -gC:\\Users\\Administrator\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\Admi...//省略+ hexo-cli@1.0.4updated 5 packages in 53.458sC:\\Users\\Administratorλ hexo -vhexo-cli: 1.0.4..//省略tz: 2017b 创建本地博客框架Hexo 安装好后，我们就可以轻松的开始创建博客了，常用的就几条命令。 初始化博客。用来初始一个博客系统，我们新建一个目录 blog，并且在 cmder中进入到该目录，执行初始化hexo init命令。 123456789E:\\blogλ hexo initINFO Cloning hexo-starter to E:\\blogCloning into &apos;E:\\blog&apos;...remote: Counting objects: 62, done.remote: Total 62 (delta 0), reused 0 (delta 0), pack-reused 62...added 338 packages in 69.358sINFO Start blogging with Hexo! 查看文件目录结构。初始化后，它的文件结构如下。其中 source/_posts 文件件，这个就是博客的内容，我们以后可以在这个目录新建 .md 文件，就可以了。初始状态下有个默认的hello-world.md 文件。 本地部署。 通过 hexo g hexo s 就可以查看了，然后在浏览器中输入 http://localhost:4000/ 就可以查看刚才本地部署的博客，至此本地博客系统已经成功架起来了，按下ctrl+c 终止，接下来，我们将此博客部署到 GitHub Pages 上去。 部署博客到 GitHub Pages上Hexo 中可以通过修改配置文件，来指定需要部署到哪里去，它使用的是 yaml格式文件，对格式很严格，记住冒号后需要加一个空格。 修改 _config.yaml 文件。这个文件可以修改标题，作者等信息，拉到最下面是部署的目的地，按照如下格式设定，我的部署如下 12345deploy: type: git repository: github: git@github.com:cloudy-liu/cloudy-liu.github.io.git branch: master 安装 Hexo git 部署插件，让 Hexo知道通过什么类型部署，这里是 git 12E:\\blogλ npm install hexo-deployer-git --save 开始部署到 GitHub Pages，通过如下命令 hexo clean hexo g hexo d 12345678910111213141516171819E:\\blogλ hexo cleanINFO Deleted database.INFO Deleted public folder.E:\\blogλ hexo gINFO Start processing...INFO 28 files generated in 641 msE:\\blogλ hexo dINFO Deploying: gitINFO Setting up Git deployment.......To git@github.com:lynnbest/lynnbest.github.io.git + bbfcc20...08c6344 HEAD -&gt; master (forced update)INFO Deploy done: git 浏览器打开 https://cloudy-liu.github.io/ ，就可以看到部署到结果。 至此，别人就可以通过类似 https://cloudy-liu.github.io 方式访问你的博客了。 小结本文详细记录了如何使用Hexo 结合 GitHub Pages 快速搭建个人博客，同时推荐了一个 Windows 超好用的终端 Cmder ，如果觉得本文对你有用，那就一个转发或者一个赞吧。同时欢迎关注微信公众号 “YunShell”。 （全文完）","link":"/2018/02/26/Hexo+GitHub快速搭建个人博客之一/"},{"title":"Hexo+GitHub 快速搭建个人博客之二","text":"在上一篇 Hexo+GitHub 快速搭建个人博客之一 中，介绍了如何使用 GitHub Pages 和 Hexo 搭建一个博客， 但是还没有绑定个人域名，如果你没有个人域名，那就要去购买一个了，这也是唯一一个需要花钱的地方，当然最低只需要花费2块钱就可以了，这个接下来会谈到具体的操作。 另外，本篇还会顺带讲解一下，如何将博客同时部署在 Coding 上。Coding.net 是提供类似于 GitHub 服务的国内网站，好处在于访问速度快很多，同时一样提供了好用的 Coding Pages 功能，用于托管个人博客服务。后面会讲解到 Hexo 如何同时部署到 GitHub Pages 和 Coding Pages，其实类似于 GitHub Pages 的操作。 下面将按照以下顺序进行动手操作 GitHub Pages 绑定个人域名 阿里云购买域名 将域名映射到 GitHub Pages 上 Hexo 同时部署博客到 GitHub Pages 和 Coding Pages 上 GitHub Pages 绑定个人域名阿里云购买域名因为我在阿里云购买了域名，所以这里以阿里云为例。当然也可以在其他地方购买，比如腾讯云。进入阿里云官网，找到 产品/域名与网站 ，点击进入，如果没有阿里云账号，需要先注册，如下图所示。 此时你可以看到各个后缀的域名了，有 .com .top 之类的，可以看到 .top 的域名最低只需要2块钱就可以，购买前先查询一下你的域名是否已被注册了，购买流程就不赘述。购买完毕后，域名需要实名认证，这个过程大概一至两天就可以通过了，之后这个域名就是你属于你个人专有了。 将域名映射到GitHub Pages上这步的目的是，当我们在浏览器中直接输入我们刚才购买的域名（比如我的 www.liuyun.fun），就可以直接跳转到我们部署到 GitHub Pages 上的博客网站，而无须输入类似 username.github.io 这样不好记的网址了。那么要如何操作呢？在上篇中，我们已经能通过 username.github.io 的网址来访问托管的博客了，为了达到刚才的目的，我们需要做的是，建立个人域名与 username.github.io 的映射关系，要完成这个映射关系，需要按照以下几个步骤进行操作。 获取你 github.io 的 IP 地址通过 Ping 你的github.io 这个网址，如下图所示 域名服务商进行域名解析我这里是阿里云的后台管理界面，进入到 云服务 DNS 界面，点击 解析设置 然后点击添加 添加解析 在弹出的界面中，选择记录类型为 A 类，意思是该域名的地址会跳转到我们设定的目的地，记录值方框填写刚才的 Ping 出的 IP 地址。这里我们添加两个 一个是 www，一个是 @ 添加完毕后，结果是这样的 GitHub Pages 设定进入到你自己的 GitHub Pages 项目，我这里的是 cloudy-liu.github.io ，进入该项目的 Settings ，向下拖动到 GitHub Pages 位置，目前你看到的是该网站 publish 到 https://cloudy-liu.github.io我们找到 Custom domain 进行自定义域名绑定，这里输入你购买的自定义域名，我这里是 www.liuyun.fun ，如下图所示。 保存完毕后，它 publish 的网址就更改为你刚才修改过的域名地址了，需要注意的是，刚才我们的动作，其实在 GitHub Pages 仓库中添加了一个 CNAME 的文件，该文件内容就是保存自定义域名的地址，这也就是，很多人也可以通过添加 CNAME 文件来绑定域名，其实这是一回事，只不过现在 Github 直接支持绑定自定义域名了，就不同在 push 代码了。需要注意的是，你每次更新文章时，会重新 clean 一次，因此需要将 CNAME 文件加入到你Hexo source 中，这样确保每次可以 push 到 github 仓库中, 了解更多 此时，你在浏览器中输入你自己的域名网址，就可以直接跳转到 Github Pages 的个人博客了，至此，个人博客的就绑定完毕了。 同时部署博客 Coding Pages 上这步其实是个备选题，如果你对博客的访问速度有需求，那么就可以考虑同时在部署博客到 Coding 上，毕竟国内的服务器速度要快。 开启 Coding Pages 的步骤其实和 GitHub Pages 大同小异，它们官网说明的非常清楚，只需要照着做就好了，没什么困难。 注册一个 Coding 账号需要提醒的是，为了一致性，可以将 Coding 的账号邮箱设定和 Github 一样，这样一同部署就方便多了。 开启 Pages 服务官网已经讲解非常清楚，照做就好， https://coding.net/pages/ 在 Coding 网站， 绑定 ssh可以复用之前在 GitHub 绑定已经生成好的 ssh 的内容。绑定好后，在通过以下命令，检查一下 1$ ssh -T git@git.coding.net 增加部署到coding 网站修改 Hexo 的 _config.yml 文件 123456deploy: type: git repository: github: git@github.com:cloudy-liu/cloudy-liu.github.io.git coding: git@git.coding.net:cloudy-liu/cloudy-liu.coding.me.git branch: master 接下来，就可以使用 hexo d 部署到新博文到 Github 和 Coding ，当然这里 Coding 还是需要通过 Coding Pages 的域名直接访问，比如我的是 cloudy-liu.coding.me 访问刚才更新的博客内容。 小结本篇讲解了 Github Pages 如何绑定个人域名，以后就可以通过个人域名直接访问博客，同时顺带提了一下同时将博客部署到 Coding 中的几个步骤，希望对你有帮助。 (全文完） 相关链接： Hexo+GitHub 快速搭建个人博客之一","link":"/2018/02/27/Hexo+GitHub快速搭建个人博客之二/"},{"title":"Hexo yilia 主题一揽子使用方案","text":"在用 Hexo 搭建完毕后，接着就寻找主题了，对比了几个主题 ，发现这个yilia 主题比较干净，简洁，于是就选了这个主题，但是有些细节不太习惯，于是就研究调整了一下，就是现在这个博客的样子。 查看所有文件，提示缺失模块yilia 在首次使用时，点击所有文章 时，会出现模块找不到的错误，可按照提示操作即可注意一下，_config.yml 路径是指 根目录下的，而非 yilia 主题下的 config文件 配置图片资源 添加图片资源文件夹。 路径为 themes/yilia/source/下，可添加一个 assets 文件夹，里面存放图片资源即可 配置文件中直接引用即可。路径为 themes/yilia/_config.yml，找到如下即可 123456# 微信二维码图片weixin: /assets/img/wechat.png# 头像图片avatar: /assets/img/head.jpg# 网页图标favicon: /assets/img/head.jpg 文章如何显示摘要 问题。点击主页时，发现所有文章都是全文显示，不利于查找，可控制显示的字数 解决办法。 在你 MD 格式文章正文插入 &lt;!-- more --&gt;即可，只会显示它之前的，此后的就不显示，点击文章标题，全文阅读才可看到，同时注释掉以下 themes/yilia/_config.yml，重复 1# excerpt_link: more 效果 文章显示目录增加文章目录 TOC(table of content )，方便阅读文章, 在 themes/yilia/_config.ym中进行配置 toc: 2即可，它会将你 Markdown 语法的标题，生成目录，目录查看在右下角。 增加归档菜单修改 themes/yilia/_config.yml 123menu: 主页: / 归档: /archives/index.html 修改代码块样式默认的代码样式太刺眼了，调成稍微柔和一些的，这里是调成 Atom 风格，以下为两种方式都可以，推荐第一种直接修改编译好的文件，不然还需要重新build。 直接修改编译好的文件。路径为： theme\\yilia\\source\\main.0cf68a.css 修改代码背景色，搜索 .article-entry .highlight, 修改background后面的颜色 修改代码字体颜色 .article-entry .highlight .line 修改源文件重新build。上述资源对应源文件为 yilia\\source-src\\css\\highlight.scss，按照如下方式build 1234cd 到 yilia 目录下npm installnpm run devnpm run dist 增加不蒜子统计利用这个统计，可以知道你博客的访问量 安装不蒜子脚本udpate: 2019/9/15 在 themes\\yilia\\layout\\_partial\\after-footer.ejs最后添加，注意以下新的域名才有效，老的已经失效了 12&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 添加统计网站访问量修改 themes\\yilia\\layout\\_partial\\footer.ejs，包括访客数和站点访问总量 12345# PV方式，单个用户连续点击 n 篇，记录 n 次记录值&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;# UV方式，单个用户连续点击 n 篇，记录 1 次记录值&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 单篇文章点击量 themes\\yilia\\layout\\_partial\\article.ejs中 在 &lt;%- partial('post/title', {class_name: 'article-title'}) %&gt; 插入如下代码 12345678910&lt;!--显示阅读次数--&gt;&lt;% if (!index &amp;&amp; post.comments){ %&gt; &lt;br/&gt; &lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp; &lt;/span&gt; &lt;/a&gt; &lt;% } %&gt; 添加来必力评论系统点击这个链接 查看 添加版权信息点击这个链接 查看 插入网易云音乐 登入网易云音乐网页版，选择一首歌，点击歌曲详情，点击生成外链播放器 复制外链代码，插入你需要编辑的 MD 格式文章里面，即可 百度/Google统计/SEO点击这个链接查看，这几项都是相同的 七牛云图床博客内容最麻烦的就是插入图片，我们可以使用七牛云提供的 10G 的免费存储空间，将图片上传上去，然后生成外链，使用 Markdown 的图片引用方法即可，这样文章就脱离了图片编辑，转为在线了。同样一份文章，你部署在 csdn 等其他网页时，直接复制粘贴即可。 上传图片到七牛云 注册，并完成支付宝实名认证，实名认证后有10G的免费空间，认证免费额度 添加文件。步骤为添加 对象存储, 新建一个存储空间，进入到该空间，点击 内容管理,点击上传文件 生成外链插入到文章中 使用 PicGo 自动生成外链但是这样通过 web点击上传按钮方式，太效率了，这里使用 PicGo 工具，完成拖动自动生成外链，感谢作者。 查看你的七牛密钥。登入七牛云查看密钥 个人面板 -&gt; 密钥管理 PicGo 配置七牛账户。然后就在上传图，拖动图片进去，即可生成外链，直接插入到文章中即可。 Demo测试修改配置后，输入以下三条命令即可部署 123hexo cleanhexo ghexo d 点击这里 查看博客正文的效果 以上希望对你所有帮助。 （全文完）","link":"/2018/04/07/Hexo_yilia_主题一揽子优化方案/"},{"title":"Hexo博客图片链接失效问题解决","text":"博客中的图片失效很久了，一直没时间来处理。现在把解决过程整理了一下，供同样问题的人参考 失效原因因为我的博客图床是托管在七牛云存储上(个人免费10G)，但是目前七牛云提供的测试域名均只有 30天的试用期，过了试用期会被回收，导致图片链接失效。解决的方法就是按照七牛云的指导，绑定自定义域名，并且该域名必须要工信部备案，而这个备案过程至少要20+天，时间非常长，我这目的也仅仅是为博客做图床而已，因此不想去申请麻烦的备案。因此另谋出路。 需求整理 另找一个可简单使用的图床，不需要备案之类的 可一直存储图片 访问速度要还凑合 最后经过选择，使用 coding 项目作为图床，coding跟腾讯云开发者绑定后，项目数和速度都免费畅享，也就是项目可以一直开下去，下图就是升级之后的好处 图片转移 Step 新建 coding 项目，将之前博客中的图片都上传上去 我因为本地没有保存之前的图片了，这个可以在七牛云上申请工单处理，可延长你的测试域名期限，我的延长了3天，然后批量下载下来了。 上传完了图片后，随便点击一张图片，查看这个图片的完整链接 比如 这里：https://coding.net/u/cloudy-liu/p/BlogPicBed/git/blob/master/1.png，我们将其中的blob 替换成 raw ，然后在修改为 markdown的链接语法： ![](https://cloudy-liu.coding.net/p/BlogPicBed/d/BlogPicBed/git/raw/master/1.png) 就可以在 markdown 支持的文本中看到这张图片了 使用新的图片链接替换你原博文中的图片链接 因为用 markdown 写的博文，图片都是链接的形式，比如之前的博文图片链接都是七牛云域名的图片，如 ![](http://p5sfmckwy.bkt.clouddn.com/img/2_top_2_rmb.png)，现在仅需要替换为新的域名即可，因为图片的名字不用改，只需要修改之前的域名为 coding 新建项目上的域名即可，当然博文非常多，我这里写了简单的 python 脚本来一次性批量处理 replace_pic.py 代码如下 123456789101112131415161718192021222324252627282930313233343536# coding=utf-8import argparseimport osimport reOLD = \"http://xxx.clouddn.com/img/\" #修改为你原来图片地址NEW = \"https://xxx/git/raw/master/\" #修改为你coding项目图床地址def get_arg(): parser = argparse.ArgumentParser() parser.add_argument(\"-p\", \"--path\", type=str, dest=\"path\", help=\"blog article path\") args = parser.parse_args() path = args.path print(\"path: \", path) replace_path = path.replace(\"\\\\\", \"/\") print(\"replaced_path:\", replace_path) return replace_pathdef main(path): file_list = [os.path.abspath(os.path.join(root, file)) for root, _, files in os.walk(path) for file in files] print(file_list) print(\"start ..\") for f in file_list: content = \"\" with open(f, \"rb\") as fp: file_content = fp.read() content = re.sub(OLD, NEW, file_content) with open(f, \"wb\") as fp: fp.write(content)if __name__ == '__main__': main(get_arg()) 使用方式，-p 指定目录后，会将该目录下的所有文件，将旧的链接替换为新的链接 1python 路径/replace_pic.py -p 你博文的目录 修正后，在更新 hexo d -g 进行更新博客即可，图床即更换了 更新 Coding 因为最近调整，导致原有的个人项目被迁移，但是迁移后的项目默认没有public，所以想要将 coding 做图床，需要将该项目设置为 public 的， 路径为 代码仓库 -&gt; 仓库设置 -&gt; 公开源代码 ，然后再利用 replacce_pic.py 进行更新 最后编辑于 2020-05-11","link":"/2019/05/23/Hexo博客图片链接失效问题解决/"},{"title":"Hexo 主题迁移到 icarus","text":"yilia 在大屏下被拉伸的太长了，一直想换三栏模式，最近看到 icarus主题，设计的非常漂亮，于是果断换 (怎么现在尽是在折腾Hexo 主题啊，Orz…) 配置 icarus 主题下载 icarus ，在 hexo 的 themes 文件夹，新加入 icarus 目录，配置 hexo 的根目录的 _config.yml _config.yml12-theme: yilia+theme: icarus 然后更新部署就好了 1hexo d -g 自定义 icarus 主题默认配置也基本能用了，但是有一个痛点就是，阅读模式文章宽度太短了，还是根据个人习惯做下配置下 配置 gitalk 评论icarus 默认是支持 gitalk 的，所以只需要在 themes/icarus/_config.yml 中设置一下即可 themes/icarus/_config.yml12345678comment: # Name of the comment plugin type: gitalk owner: cloudy-liu # (required) GitHub user name repo: cloudy-liu.github.io # (required) GitHub repository name client_id: xxxx # (required) OAuth application client id client_secret: xxx # (required) OAuth application client secret admin: cloudy-liu 还没配置的可以参考这篇做配置 代码高亮代码高亮款式 , 预览参见这里，Android 程序员选择 androidstudio 效果不错 themes/icarus/_config.yml1highlight: androidstudio 调整阅读模式双栏判断 post 页面，显示目录 toc ，修改宽度 themes/icarus/includes/helpers/layout.js123456789- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ if (this.page.layout !== 'post') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ }+ if (position === 'right') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc'));+ } else {+ return []+ } themes/icarus/layout/common/widget.ejs123 case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; themes/icarus/layout/layout.ejs123456789101112 &lt;head&gt; &lt;%- partial('common/head') %&gt; &lt;/head&gt;-&lt;body class=\"is-&lt;%= column_count() %&gt;-column\"&gt;+&lt;body class=\"is-3-column\"&gt; &lt;%- partial('common/navbar', { page }) %&gt; case 2:- return 'is-8-tablet is-8-desktop is-8-widescreen';+ return 'is-8-tablet is-8-desktop is-9-widescreen'; case 3: return 'is-8-tablet is-8-desktop is-6-widescreen' } themes/icarus/source/css/style.styl12345678910 .is-2-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap+ .is-3-column .container+ max-width: screen-widescreen - gap+ width: screen-widescreen - gap @media screen and (min-width: screen-fullhd)+ .is-3-column .container+ max-width: screen-fullhd - 2 * gap+ width: screen-fullhd - 2 * gap 增加文章版权themes/icarus/layout/common/article.ejs1234567891011121314 &lt;div class=\"content\"&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt; &lt;/div&gt;+ &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) { %&gt;+ &lt;ul class=\"post-copyright\"&gt;+ &lt;li&gt;&lt;strong&gt;本文标题：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= page.title %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;&lt;a href=\"&lt;%= theme.url %&gt;\"&gt;&lt;%= theme.author %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文链接：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;发布时间：&lt;/strong&gt;&lt;%= post.date.format(\"YYYY-MM-DD\") %&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\" rel=\"external nofollow\" target=\"_blank\"&gt;CC BY-NC-SA 4.0&lt;/a&gt; 许可协议。转载请注明出处！+ &lt;/li&gt;+ &lt;/ul&gt;+ &lt;% } %&gt; &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; 下面文件加入格式 themes/icarus/source/css/style.styl123456789101112 border: none .file all: initial++.post-copyright+ font-size: 1rem+ letter-spacing: 0.02rem+ word-break: break-all+ margin: 2.5rem 0 0+ padding: 1rem 1rem+ border-left: 3px solid #FF1700+ background-color: #F9F9F9 这里大部分是参照 自定义icarus 做的修改(点赞) 更新logoicarus 有默认的 logo，这里想改变一下，logo 是在 themes\\icarus\\source\\images 里面logo.svg 文件，我们只需要替换成自己的 logo 文件即可，可以从这里 去获取。 总访问量统计icarus 是用卜算子统计，默认只统计了访问人数，并没有访问量统计，需要在页脚修改下 themes/icarus/layout/common/footer.ejs1234567891011@@ -15,9 +15,8 @@ href=\"https://github.com/ppoffice/hexo-theme-icarus\" target=\"_blank\"&gt;Icarus&lt;/a&gt; &lt;% if (has_config('plugins.busuanzi') ? get_config('plugins.busuanzi') : false) { %&gt; &lt;br&gt;- &lt;span id=\"busuanzi_container_site_uv\"&gt;- &lt;%- _p('plugin.visitor', '&lt;span id=\"busuanzi_value_site_uv\"&gt;0&lt;/span&gt;') %&gt;- &lt;/span&gt;+ &lt;span id=\"busuanzi_container_site_uv\"&gt; 来访 &lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人&lt;/span&gt;+ &lt;span id=\"busuanzi_container_site_pv\"&gt;, 总访问 &lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; &lt;% } %&gt; &lt;/p&gt; 修改主题后，建议先进行清理，不然可能由于缓存问题，导致本地预览与部署不一致，KO ! 12hexo cleanhexo d -g 参考资料 icarus文档 自定义 icarus","link":"/2019/06/23/Hexo主题迁移到icarus/"},{"title":"Hexo-yilia使用gitalk/gitment评论系统","text":"来必力总是显示异常，现在抽时间找些资料，将博客评论系统更换为 gitment/gitalk。 。最好两种都尝试之后，选择使用gitalk ，界面更加好看，配置也简单。下面就是两种配置的详细步骤。 Gitment 的原理是利用 github 上的 issue 系统，也就是你提的评论都会对应生成 issue。当然账户只能是通过 github 账号。这点跟来必力有点差，不过博客的受众大部分都是程序员，所以也可以接受。 Hexo-yilia gitment 配置yilia 主题默认是支持 gitments的，所以只需要进行配置。 注册 OAuth Application当别人评论你的文章时，会需要它是授权。点击 https://github.com/settings/applications/new 进行注册。注册界面如下。 注册成功后，会获取到 Client ID/scerct 。如下图所示，接下来就是将信息填入配置文件中。 配置 _config.yml 文件打开themes\\yilia\\_config.yml ,在如下位置填入正确的信息即可。 gitment_owner: 填写你的 github 账户名即可 gitment_repo: repo 名字为可新建一个repo 或者使用博客托管的 repo 都行。 client_id和client_secret : 就是上步骤中注册的获取的信息。 重新部署配置完毕后，重新部署，即可看到效果。 1hexo g -d 解决Valid Fail部署后，每次文章的评论都会需要初始化，但是试验是发现初始化失败，查找资料后，发现是 github issue 本身的规则限制（label 的长度最长为50），可参考Gitment评论功能接入踩坑教程 。 解决方法，将 github issue 的 id 改为按照日期方式。 文件位置：themes\\yilia\\layout\\_partial\\post\\gitment.ejs 1234ar gitment = new Gitment({ // id: &quot;&lt;%=url%&gt;&quot;, id: &apos;&lt;%= page.date %&gt;&apos;, owner: &apos;&lt;%=theme.gitment_owner%&gt;&apos;, 重新部署即可。 Hexo-yilia gitalk 配置gitalk 风格感觉更加好看，维护的也比较勤。具体的配置方法，请参考 Hexo主题yilia增加gitalk评论插件 。然后重新部署hexo d -g 生成之后的样式如下。 (完）","link":"/2018/07/14/Hexo更换为GitTalk评论系统/"},{"title":"博文样式测试","text":"这里是为了测试Hexo Markdown 的效果 标题测试这是一级标题这是二级标题这是三级标题这是四级标题图片引用 代码样式test.py123def fibc(n): assert isinstance(n, int) and n &gt;= 0 return fibc(n - 1) + fibc(n - 2) if n &gt; 2 else n 引用 这是一个引用 数学公式$x=\\dfrac{ -b \\pm \\sqrt{b^2 - 4ac}} {2a}$ 表格测试 one tow three one one one one one one one one one 序列 test one test two test three 插入音乐测试 版权测试","link":"/2018/02/27/test/"},{"title":"括号匹配算法","text":"括号匹配习题 题目Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. 12345Input: &quot;()&quot;Output: trueInput: &quot;([)]&quot;Output: false 思路题目说仅有各种左括号和右括号的组合。可以使用栈的数据结构，因为匹配的括号的话，一定是成对出现的，若将左括号一次压入栈，遇到匹配的右括号在弹出栈，则若是匹配的话，栈最后一定为空。 遍历字符串，当遇到左括号时候，将其压入栈中，当是右括号时，看是否栈为空，若是空则直接返回(“)”，否则在看是否和栈顶元素匹配，若匹配，则出栈，若不匹配则直接返回false。遍历完成后，若栈为空，则返回true，否则返回false。 Solution基于以上的解法 1234567891011121314151617181920public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char currentChar = s.charAt(i); if ((currentChar == '(' || currentChar == '[' || currentChar == '{')) { stack.push(currentChar); } else if (stack.isEmpty()) { return false; } else { Character top = stack.peek(); if ((top == '[' &amp;&amp; currentChar == ']') || (top == '{' &amp;&amp; currentChar == '}') || (top == '(' &amp;&amp; currentChar == ')')) { stack.pop(); } else { return false; } } } return stack.isEmpty();} 此题虽然AC了，但是看了 leetcode 讨论区，发现一个非常简洁的写法，它将其翻转过来，上面我们压入栈的是左括号，而他压入栈的是右括号，在遇到右括号时，弹出栈，判断是否弹出的栈顶元素就是当前扫描的右括号，若不是，则不是匹配的字串，返回false，最后遍历完成后，判断栈是否为空。代码简洁好多。 12345678910111213141516public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); if (c == '(') { stack.push(')'); } else if (c == '[') { stack.push(']'); } else if (c == '{') { stack.push('}'); } else if (stack.isEmpty() || stack.pop() != c) {// consider opposite side, very smart return false; } } return stack.isEmpty();} 完整source code","link":"/2018/07/01/leetcode20/"},{"title":"七大排序算法总结(Java实现版)","text":"这节开始总结7种最常用的排序算法，先来看看最简单的冒泡算法。 所有完整源代码点击github 这里 查看。我们假设测试数据集为以下数组，要求按照从小到达的升序排列。 而排序的动图演示，可以参考 http://www.atool.org/sort.php 1234567891011121314public static void main(String[] args) { int[][] data = new int[][]{ new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},//逆序 new int[]{1, 2, 3, 4, 5, 6, 7},//正序 new int[]{1, 7, 3, 5, 0, 2, 4, 8, 6}};//随机 for (int i = 0; i &lt; data.length; i++) { System.out.println(\"before sort\"); BaseSort.printArray(data[i]); ... System.out.println(\"after sort\"); BaseSort.printArray(data[i]); } } 冒泡排序思路基于相邻比较和交换的方法。针对 n个数，一共会有 n-1 轮。每轮将确定一个值的最终位置，比如升序，那么每轮将会该轮中最大的数的位置确定。 Java 实现先实现交换的辅助函数 123456789public void swap(int[] a, int indexI, int indexJ) { if (a == null || indexI &gt;= a.length || indexJ &gt;= a.length) { System.out.println(\"a is null ,index out of bound\"); return; } int tmp = a[indexI]; a[indexI] = a[indexJ]; a[indexJ] = tmp;} 冒泡排序实现 1234567891011public void bubbleSort(int[] input) { int rightSide = input.length; while (rightSide - 1 &gt; 0) { // 控制比较次数，比较次数为 len-1 for (int i = 1; i &lt; rightSide; i++) { //每轮下两两比较 if (input[i - 1] &gt; input[i]) { swap(input, i - 1, i); } } --rightSide; }} 你可以看到，当测试集为正序时候，仍然需要$O(n^2)$ 的复杂度，其实每一轮遍历中，两两比较，若整个序列没有发生交换，其实排序就已经可以停止了，比如正序情况下，第一轮两两比较时，由于都是正序，所以一边遍历后没有任何交换，此时就需要停止了。若发生交换，则记录最后一个交换的位置，则该位置为下次交换遍历的终点位置。减少不必要的比较。优化的代码如下 1234567891011121314public void bubbleSortOpt(int[] input) { int rightSide = input.length; int lastCompareIndex = rightSide;//记录最后一个比较的右边界，同时充当哨兵，是否停止 while (lastCompareIndex &gt; 0) {//是否要停止 rightSide = lastCompareIndex; lastCompareIndex = 0; //若未发生交换，则会停止 for (int i = 1; i &lt; rightSide; i++) { if (input[i - 1] &gt; input[i]) { swap(input, i - 1, i); lastCompareIndex = i;//记录最后一个发生交换的位置，下次比较的右边界 } } }} 这样复杂度，在最好的情况下（已经有序），可以变为$O(n)$ 复杂度分析间复杂度 排序算法的时间复杂度在于交换和比较的次数，因此交换和比较次数的总和越小，那么时间复杂度越低，冒泡排序一个有 n -1 轮的遍历，每轮遍历中，比较次数依次为 n-1,n-2,…1 。因此比较次数的总和为 $sum=\\sum_{1}^{n-1}=1+2+…+n-1=\\dfrac{n(n-1)}{2}$ 为 $O(n^2)$ 最差情况下（逆序），那么比较一次，就要交换一次。因此总次数为 n(n-1) ，为 $O(n^2)$ ，而最好的情况下，已序的情况下，经过优化后的冒泡为 n-1 次完成，$O(n)$ ,因此平均复杂度为 $O(n^2)$ 。 空间复杂度 因为都是固定的几个局部变量，因此空间复杂度为 O(1) 稳定性 因为是基于比较，所以冒泡排序是稳定，所谓稳定性就是指相等的两个数 a,b，排序后，a,b的前后位置不变，若a在b前，则排序后仍是a在b前，否则称为不稳定。 选择排序思路选择排序也是生活中比较常见的一种思路。和冒泡相比，它减少了交换的次数，冒泡相邻的两个数比较，一旦符合交换条件，就会进行交换。选择排序则是一次性找到最后的index值，在一次性的交换。 Java 实现1234567891011121314public void selectSort(int[] data) {//升序排序 int len = data.length; for (int i = 0; i &lt; len; i++) { int minIndex = i; //初始化假定i为最小值的索引 for (int j = i + 1; j &lt; len; j++) {//从 i+1处，开始寻找最小值的索引 if (data[minIndex] &gt; data[j]) { minIndex = j; } } if (minIndex != i) { //比较一轮下来后，minIndex位置若发生变化，交换 swap(data, minIndex, i);//swap函数实现间完整代码中 } }} 复杂度分析时间复杂度 由于是逐一确定每个索引位置处最合适的值，因此最好的情况和最差情况，都需要进行比较, $Sum=\\sum_{i=1}^{n-1}=1+2+3+..+n-1=\\dfrac{n(n-1)}{2}$，因此复杂度均为为 $O(n^2)$ 空间复杂度 因为都是固定的几个局部变量，因此空间复杂度为 O(1) 稳定性 不稳定。举个例子分析，3,1,3, 2 ，第一趟时 index=0为3，逐一确定最小值的索引，所以此时2为最小的值，因此第一个3要与2交换，这样第一个3就在第二个3后面，破换了相等两个值之前的顺序了。因此是不稳定的。 直接插入排序思路直接插入排序基本思想是将一个数插入一个已经有序的数组中，默认有序的为index=0的第一个数，然后逐渐将第i个数插入[0~i-1] 这样有序的数组中。因此可以看出直接插入排序，在已经基本有序的数组中，排序效率是很高的。 Java实现1234567891011121314public void insertSort(int[] data) { int len = data.length; //思想：将一个数插入已经有序的数组中，刚开始有序的为index=0的一个数 for (int i = 1; i &lt; len; i++) { if (data[i] &lt; data[i - 1]) {//若不满足，则该值已经有序,无须插入 int tmp = data[i]; //保存 data[i]值，后面 data[i]位置要被填坑 int j; for (j = i - 1; j &gt;= 0 &amp;&amp; tmp &lt; data[j]; j--) {//逐一向前插入，数组移动 data[j + 1] = data[j]; } data[j + 1] = tmp;//j+1位置为需要插入的位置 } }} 复杂度分析时间复杂度 最好情况下，每次插入前的比较都不满足，所以遍历一遍就结束 ，复杂度为 $O(n)$ 最差情况下，从i=1处开始，每次都要发生数组移动，移动次数为 $1+2+3+…+n-1=\\dfrac{n(n-1)}{2}$ 比较次数也一样，因此复杂度为 $O(n^2)$ 空间复杂度 几个局部变量，复杂度为 $O(1)$ 稳定性 基于比较，因此能保持相等的两个数的相对位置，是稳定的。 希尔排序思路借助直接插入排序。基本思想是将整个数组分步逐渐变为基本有序，到全有序。首先确定step，就是将整个数组分组，比如 step=2。那么就是该数组 索引位置 [0,2,4,6,..] 的子序列做插入排序，这样子序列完成有序。接着在step=1.那么就是所有的数组在做插入排序。 Java实现123456789101112131415 public void shellSort(int[] data) { int len = data.length; for (int step = len / 2; step &gt; 0; step /= 2) {//将数组分为几次做插入排序 for (int i = step; i &lt; len; i++) {//step 为间隔 if (data[i - step] &gt; data[i]) {//和插入排序一样， int tmp = data[i]; int j; for (j = i - step; j &gt;= 0 &amp;&amp; tmp &lt; data[j]; j -= step) {//只不过 -1换成-step data[j + step] = data[j]; } data[j + step] = tmp; } } }} 复杂度分析时间复杂度 希尔排序是第一批突破 $O(n^2)$ 的算法，算法的复杂度跟 step 步长有关系。见维基百科 空间复杂度 几个局部变量，复杂度为 $O(1)$ 稳定性 由于是跳跃式的移动，因此是不稳定的。 归并排序思路归并的意思包含两层，一个是分治，一个是合并。思想是将一个待排序的数组，分为两个有序的数组，然后将这两个有序数组合并为一个。 Java实现123456789101112131415161718192021222324252627282930313233343536373839404142 public void mergeSort(int[] data) { int len = data.length; int[] tmp = new int[len]; mergeSortImplementRecur(data, 0, len - 1, tmp); } //递归实现 private void mergeSortImplementRecur(int[] data, int firstIndex, int lastIndex, int[] tmp) { if (firstIndex &gt;= lastIndex) {//递归的截止条件 return; } int midIndex = (firstIndex + lastIndex) / 2; mergeSortImplementRecur(data, firstIndex, midIndex, tmp); mergeSortImplementRecur(data, midIndex + 1, lastIndex, tmp); mergeArray(data, firstIndex, midIndex, lastIndex, tmp); }//非递归实现，TODO private void mergeArray(int[] data, int firstIndex, int midIndex, int lastIndex, int[] tmp) { int i = firstIndex; int n = midIndex; int j = midIndex + 1; int m = lastIndex; int k = 0; while (i &lt;= n &amp;&amp; j &lt;= m) {//逐一比较，将小的放入到 tmp数组中 if (data[i] &lt; data[j]) { tmp[k++] = data[i++]; } else { tmp[k++] = data[j++]; } } while (i &lt;= n) {//两个数组长度不一致时 tmp[k++] = data[i++]; } while (j &lt;= m) { tmp[k++] = data[j++]; } for (i = 0; i &lt; k; i++) {//复制到tmp数组中 data[firstIndex + i] = tmp[i]; } } 复杂度分析时间复杂度 每次合并将两个有序的数组合并一起，需要遍历一次，因此复杂度为$O(n)$ ，而要合并多少次？由于二分，所以次数为 $log_2n$ 次，所以总的时间复杂度： $nlog_2n$ 。进一步可以到，不管是正序，逆序复杂度均一样，因此效率比较高。 空间复杂度 因为归并排序使用了一个同等规模的额外辅助数组，这个复杂度为 $O(n)$，采用递归调用的话，因为递归栈的深度为 $log_2n$，因此总的是$O(n+log_2n)$。若采用的是非递归，那么递归栈部分可以省略，效率更高，复杂度为 $O（n)$ 。因此优先使用的是非递归的实现。 稳定性 由于也是基本两两比较，因此也是稳定性的 堆排序TODO 快速排序思路“分治”+”填坑“法。基本思路为，选取一个基准值，比如index=0的值，然后唯一确定这个基准的位置，使得该值前面的数都小于它，后面的数都大于它，这样就唯一确定了这个基准值的位置。然后在分别进行递归操作，逐一逼近单一数组值。而在确定基准值时候，是采用两头法，假设基准值为index=0的值，先保存好基准值，然后先从右游标向左找起，若是升序排序，则一直找到比基准值小的位置，停住。然后将该值填入基准值的坑，然后在从左往右找大于基准值的位置，找到后，将该值插入右边出现的坑。直到左右游标相遇，则该值就是基准值的位置填入，这样一轮下来，就唯一确定基准值了。然后在递归左序列和右序列。 Java 实现12345678910111213141516171819202122232425262728 public void quickSort(int[] data, int start, int end) { if (start &gt;= end) { return; } int base = data[start];//start 位置为基准值 int i = start; int j = end; while (i &lt; j) { while (i &lt; j &amp;&amp; data[j] &gt;= base) {//从右往左找小于的位置 j j--; } if (i &lt; j) { data[i++] = data[j]; } while (i &lt; j &amp;&amp; data[i] &lt;= base) { //从左往右找大于基准值的i i++; } if (i &lt; j) { data[j--] = data[i]; } } if (i == j) {//此时i为基准值的索引 data[i] = base; } quickSort(data, start, i - 1);//递归调用左序列 quickSort(data, i + 1, end);// 递归调用右序列} 上面的实现是快排的基本实现，但是可以看出，有许多地方可以进行优化。 基准值改进 首先基准值的选择比较重要，假设基准值每次都是选取了最大或是最小，其实一轮下来，数据量只是减少了一个，假设每次基准值都是选择比较平均，都是中间的值，那么每轮下来，数据量都会减小一半。可以采用取首位，中间值三者的中值来作为基准值。 尾递归改进 由于快排是基于递归实现，所以数据量大的时候，会造成调用栈深度过大，因此改为尾递归调用 小数量时，退化为直接插入排序 所以优化后的快排为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void quickSortOpt(int[] data, int start, int end) { if (end - start &lt; MAX_SORT_NUMBER) {//优化1，小数据采用 直接插入法 insertSort(data, start, end); } else { while (start &lt; end) {//优化2,尾递归减少调用栈 int i = start; int j = end; //优化3。采用中值法，选择基准值 int mid = (start + end) / 2; if (data[start] &gt; data[end]) { swap(data, start, end); } if (data[mid] &gt; data[end]) { swap(data, mid, end); } if (data[mid] &gt; data[start]) { swap(data, mid, start); } int base = data[start]; while (i &lt; j) { while (i &lt; j &amp;&amp; data[j] &gt;= base) { j--; } if (i &lt; j) { data[i++] = data[j]; } while (i &lt; j &amp;&amp; data[i] &lt;= base) { i++; } if (i &lt; j) { data[j--] = data[i]; } } if (i == j) { data[i] = base; } quickSort(data, start, i - 1); start = i + 1;//优化2 尾递归 } } } private void insertSort(int[] data, int start, int end) { for (int i = start + 1; i &lt;= end; i++) { if (data[i - 1] &gt; data[i]) { int tmp = data[i]; int j; for (j = i - 1; j &gt;= 0 &amp;&amp; tmp &lt; data[j]; j--) { data[j + 1] = data[j]; } data[j + 1] = tmp; } } } 复杂度分析从实现来看，快排每次都需要遍历一次数组，$O(n)$ ，而最差的情况，每次分治后，都只减少一个数据，所以一共会有 n-1 次，所以此种情况下，时间复杂度为 $O(n^2)$ ，最好的情况下，是每次分治都减少一半的数据量，因此次数为 $O(logn)$ ，所以最好的情况是 $O(nlogn)$ ，空间复杂度为由于是递归调用，所以$O(logn)$ 同时又由于是跳跃的比较，所以是不稳定的。 总结 时间复杂度（最好） 时间复杂度（最差） 时间平均复杂度 空间复杂度 稳定性 冒泡排序 $O(n)$ O(n^2) $O(n^2)$ O(1) 稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ O(1) 不稳定 直接插入排序 $O(n)$ $O(n^2)$ $O(n^2)$ O(1) 稳定 希尔插入排序 $O(nlogn)$ 依据step 依据step O(1) 不稳定 归并排序 $O(nlog_2n)$ $O(nlog_2n)$ $O(nlog_2n)$ O(n) 稳定 快速排序 $O(nlogn)$ $O(n^2)$ $O(nlogn)$ $O(logn)$ 不稳定 Refs sort_wiki","link":"/2018/06/14/七大排序算法总结(Java实现版)/"},{"title":"Android Handler 消息机制","text":"本篇基于 Android 10.0 总结 Android 是基于消息机制运行的，理解消息机制的原理在日常开发中非常重要，从 App 创建开始，到点击，滑动更新页面 ，这些操作都离不开底层的消息机制，可以说消息机制是 Android 系统基石之一。 2个前提知识在剖析源码之前，我们要先了解2个最基本知识点，第一个就是先不考虑原理，作为 App 开发者如何使用消息机制编程，第二个就是 linux epoll 机制，这部分是消息机制的底层运转核心。 消息机制模型在Android中只有App的主线程才能去更新UI界面，所以主线程一般又被称为UI线程，非主线程去更新UI时，系统会抛出异常错误，所以 Android 只能在主线程去更新 UIframeworks/base/core/java/android/view/ViewRootImpl.java 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); }} 为什么会设计成单线程呢？ 原因为了高效，各个UI控件若能多线程操作，线程间同步将会是个灾难，并且很可能造成资源泄露，那么主线程和子线程如何通信呢？ 消息机制就为这个设计，另外四大组件的启动过程也都离不开消息机制的驱动。 我们先来看下Android官方文档 Looper 中关于消息机制的典型用法，其实步骤也很简单，这个例子定义了一个线程，当线程被系统调度起来执行run()方法后，先调用 Looper.prepare() 方法准备好该线程的Looper对象，然后在某个线程中初始化好一个 handler 并复写了一个处理消息的方法，最后调用 Looper.loop() 方法将消息队列循环起来，通过 mHanlder 发送和处理消息。 12345678910111213class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); // 1. 准备好 looper 对象 mHandler = new Handler() { //2. 创建一个handler对象,并指明消息处理函数 public void handleMessage(Message msg) { // process incoming messages here } }; Looper.loop(); //3.开始该线程内部消息循环 }} 接着我们通过一个 hello world App 实际操作下，这个例子的功能是，在 hello world App 基础上，增加一个按钮，点击按钮，去模拟网络下载数据，下载完毕后，最后在界面显示 “download ok” 的提示。 MainActivity 中创建一个主线程绑定的成员变量 mHandler, 并复现 handleMessage 方法，内容为当有消息类型为1时的消息，就更新界面的 textview 控件显示提示 1234567891011public class MainActivity extends Activity { private Handler mHandler = new Handler(){//创建主线程绑定的handler对象 @Override public void handleMessage(android.os.Message msg) { switch(msg.what) { case 1: mText.setText(\"download Ok!\"); break; } }; }; 在 MainActivity 的 onCreate 方法中设置按钮点击事件响应，当点击按钮时，开启子线程模拟下载，下载完成后，通过 mHandler 发送一个消息给主线程 12345678910111213141516171819protected void onCreate(Bundle savedInstanceState) { ... mButton.setOnClickListener(new OnClickListener { @overide public void onClick() { new Thread(new Runable() { @overide public void run() { //模拟等待 2s Thread.sleep(2); // 2s后发送消息给主线程通知下载完毕 Message msg = Message.obtain(); msg.what = 1; mHandler.sendMessage(msg); } }) }).start(); ...} 所以，开发者使用上就是通过 Handler, Message ,Looper 三者使用。 linux epoll 机制简述第二个就是 linux epoll 机制，它是 linux 中最高效的多路 IO 复用机制，也就是一个老师( epoll 文件描述符fd ) 可以同时管十几个学生(需要监听的 event 事件），当某个学生有问题时，都可以举手问老师，老师可以回答问题（响应事件），它适用于大量并发少量活跃的情况下，使用 epoll 的步骤有3步： 首先通过 epoll_create() 函数创建一个 epoll 文件描述符，参数 size 为能够监听的最大数量 1int epoll_create(int size)； // 创建一个epoll文件描述符，size 为能够监听的个数 通过 epoll_ctl 方法告诉 epoll fd 需要监听哪个文件描述符以及它的什么事件 1int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； 调用epoll_wait等待监控的事件到来，当有监控的事件发生，会放到 events 数据组中， timeout 为等待的时间，若未到来，则一直阻塞 1int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 好了，了解了这2个背景知识，下面我们就看下消息机制模型的源码流程。 消息机制源码分析Looper 创建和循环Looper 的本质是有一个消息队列，然后一直循环抽取消息队列里面的消息执行，当没有消息时，就休眠等待消息到来 或者做一些清理的工作。 Looper.prepare()任何线程在开始消息循环前都要进行准备工作，核心目的是创建一个该线程唯一的 Looper 对象（也就是消息队列），Looper.prepare() 方法中首先会检查该线程是否已经有了一个Looper对象，如果之前有，则会抛出异常，一个线程仅会只有一个 Looper 对象，创建好的 Looper 对象会被设置到线程私有变量中，线程私有变量是每个线程单独有的区域，由不同线程私自持有。 /frameworks/base/core/java/android/os/Looper.java 123456789101112131415public static void prepare() { prepare(true);}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); //创建 Looper对象并设置线程私有变量中}private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed);// Looper 对象的构造本质是创建一个消息队列 mThread = Thread.currentThread();} MessageQueue 创建在 Looper 创建时，会创建 Java 层的消息队列 MessageQueue, 而 Java 层 MessageQueue 创建时又会调用 JNI 方法创建一个 native 层的消息队列，并持有其指针存于成员 mPtr中，这样方便后面 Java 层操作 native 的消息队列，我们看下 Java 层 MessageQueue 构造函数 /frameworks/base/core/java/android/os/MessageQueue.java 123456789package android.os;MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; mPtr = nativeInit();//调用 android_os_MessageQueue.cpp 中native方法初始化}private long mPtr; // used by native codeprivate native static long nativeInit();// native 方法 调用关系为： MessageQueue.java -&gt; MessageQueue.nativeInit() -&gt; android_os_MessageQueue.cpp:android_os_MessageQueue_nativeInit()，最后通过 JNI 层调用 这里顺便说下，Java 层如何对应有 native 层的方法呢？ 一般规则如下，MessageQueue.java 所在包名是 android.os ，MessageQueue.java 对应的 JNI 文件名为 android_os_MessageQueue.cpp，然后将包名和文件名通过下划线链接起来就是 android_os_MessageQueue.cpp，好了，我们在来看下 JNI 层做了什么事情/frameworks/base/core/jni/android_os_MessageQueue.cpp 12345678910static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) { NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();//创建一个native 层消息队列 if (!nativeMessageQueue) { jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; } nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);//返回native层消息队列的指针} 在 JNI 层也创建一个 native 的消息队列（和 Java层的消息队列没关系），然后返回一个 native层消息队列的指针存储在 MessageQueue.mPtr中，也就是 Java层的消息队列持有 native层的消息队列的指针，接下来我们看下 nativeMessageQueue的构造 /frameworks/base/core/jni/android_os_MessageQueue.cpp 12345678NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) { mLooper = Looper::getForThread(); if (mLooper == NULL) { mLooper = new Looper(false); Looper::setForThread(mLooper); }} native 层消息队列中构造中，和 Java层一样，也会创建一个 Looper对象，将该对象存储在线程私有变量中，在 native层 Looper对象创建时，会通过 epoll 机制监听事件的发生 /system/core/libutils/Looper.cpp 1234567891011121314151617181920212223242526Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) { mWakeEventFd.reset(eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC));//初始化了一个 wakeEventfd 对象 ... rebuildEpollLocked(); //构建 epoll 事件}void Looper::rebuildEpollLocked() { ... // Allocate the new epoll instance and register the wake pipe. mEpollFd.reset(epoll_create1(EPOLL_CLOEXEC)); //1. 创建一个 epoll fd ... struct epoll_event eventItem;// 构造一个监听事件描述 memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = EPOLLIN; //监听读入，也就是当管道中有内容时，唤醒去读取 eventItem.data.fd = mWakeEventFd.get(); int result = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mWakeEventFd.get(), &amp;eventItem); // 2. 将监听的wakefd 加入到 epoll fd 中，并且监听读入事件 ... 好了，我们来总结下，目前已有的环境准备工作， 线程开始时，通过 Looper.prepare() 初始化一个线程唯一的Looper对象， 该Looper对象内部持有一个Java层的消息队列，在Java层消息队列创建时，又在 native层创建了一个 native层的消息队列和native层的Looper, 同时准备好了epoll机制环境，添加了对应需要监听的管道事件 Java层保存了 Native层的消息队列指针，以便后续操作 好了，消息队列环境准备好了，我们就可以让 消息队列循环起来了 Looper.Loop()调用 Looper.loop()方法后，消息队列就开始循环跑起来了， /frameworks/base/core/java/android/os/Looper.java 123456789101112131415161718public static void loop() { final Looper me = myLooper();//1.获取该线程的 Looper对象 ... final MessageQueue queue = me.mQueue;//获取该线程的 MsgQueue ...//省略 for (;;) {//开始死循环获取msg Message msg = queue.next(); // might block，取出下一条消息执行，没消息时阻塞等待 if (msg == null) { // No message indicates that the message queue is quitting. return; //退出消息循 } ... msg.target.dispatchMessage(msg);//msg.target 就是 handler，通过 handler 派发出去 ... msg.recycleUnchecked();// msg 是一个消息池，用完后回收 }} 整个逻辑比较简单，首先通过 myLooper() 方法获取到Looper对象（存储在线程私有变量中），取到消息队列，然后就是死循环该消息队列（链表组成），不断的取消息(queue.next())执行, 如果消息队列没有消息，则会等待消息到来，当有消息时，通过 Handler 进行分发出去，msg.target 就是一个 Handler 对象，消息发送之后，对消息进行回收。 下面在看下消息队列如何取出一条消息的， MessageQueue.next()这个函数为整个消息机制的核心，核心目的就是从消息队列中取出一条信息来执行，若消息队列为空或没有消息则会阻塞，等待被唤醒，或者做些空闲的清理工作，我们逐一解释下这个函数流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107Message next() { ... final long ptr = mPtr; ... //刚开始迭代时初始化参数 int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; //首次默认不等待 for (;;) { ... nativePollOnce(ptr, nextPollTimeoutMillis);//等消息，最大等待时间依据nextPollTimeoutMillis 的值 synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) {// 当消息队列不为空时 if (now &lt; msg.when) {//若是延迟消息，则计算还要等待的最大timeout时间 // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else {//消息队列不为空，且消息执行时间符合，开始获取一条消息 // Got a message. mBlocked = false; //将阻塞变量设为false //基于链表操作，获取消息队列的首条消息 if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; //立即 return, next()就直接返回了 } } else {//如果消息队列为空，说明当前无任何消息，设置无限等待标志（-1） // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // 逻辑能走到这里，说明消息队列为空，或者首个消息队列还没到时间执行时间，那么就趁着这个完全空闲的执行，执行空闲的操作 // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. //若消息队列为空或者首条消息未到执行时间，获取 idlerHandler的大小 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } //若此时未有pengdingIdleHanlder的任务，说明没有空闲执行的任务，那就直接等下一条消息到来 if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; //阻塞设置为 true continue; // 直接下一轮，实际是直接应用 nextPollTimeoutMillis 来做等待 } //下面是有pending的空闲任务，则逐一回调执行， if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // pending 任务做完了，立即设置 空闲任务为0，且等待时间为0，因为可能现在消息队列可能有消息了，直接查看 // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; }} 我们总结下关键点： nativePollOnce函数为核心函数，没有消息则会阻塞等待，通过 nextPollTimeoutMillis 变量控制最大等待时间，核心逻辑是通过这个变量的值确定等待时间，发送延迟消息或者一直等待消息（-1） 首次迭代进入的时候，不会等待，立即去检查消息队列有无消息，有符合的消息则直接返回，否则设定 nextPollTimeoutMillis 值等待 消息列表基于单链表实现，所以取出并移除头部消息，会用到两个变量 preMsg, mMessages 若消息队列为空或者首个消息执行时间还没到，此时主线程完全是空闲状态，若app有注册 idlehandler接口，则会利用这个空闲时间做回调 ，一个实际例子可 参考 创建方式: 添加入 IdleHandler 方式 1234567Looper.myQueue.addIdleHandler(new MessageQueue.IdleHanlder() { @Override public boolean queueIdle() { //do something return false; //false表示执行一次后移除，ture下次msg为空继续回调 }}) 下面我们继续看下核心方法 nativePollOnce MessageQueue.nativePollOnceframeworks/base/core/jni/android_os_MessageQueue.cpp JNI 层的方法，最后调用的是 native looper 的 pollOnce(timeout)方法1234567891011121314static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);}void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) { mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis);//调用 native 的 pollOnce 方法 mPollObj = NULL; mPollEnv = NULL; ...} /system/core/libutils/Looper.cpp 1234567891011121314151617181920212223242526272829303132333435int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) { int result = 0; for (;;) { while (mResponseIndex &lt; mResponses.size()) { const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) { int fd = response.request.fd; int events = response.events; void* data = response.request.data;#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - returning signalled identifier %d: \" \"fd=%d, events=0x%x, data=%p\", this, ident, fd, events, data);#endif if (outFd != nullptr) *outFd = fd; if (outEvents != nullptr) *outEvents = events; if (outData != nullptr) *outData = data; return ident; } } if (result != 0) {#if DEBUG_POLL_AND_WAKE ALOGD(\"%p ~ pollOnce - returning result %d\", this, result);#endif if (outFd != nullptr) *outFd = 0; if (outEvents != nullptr) *outEvents = 0; if (outData != nullptr) *outData = nullptr; return result; } result = pollInner(timeoutMillis);//调用的是 looper.pollInner方法 }} Looper.poInner 方法实质就是调用 epoll wait 方法来监听事件，当之前监听的事件到来的时候，就读取里面的内容，然后返回，Java 层就可以往下去获取消息执行了 123456789101112131415161718192021222324252627282930313233343536373839int Looper::pollInner(int timeoutMillis) { ... // Poll. int result = POLL_WAKE; ... struct epoll_event eventItems[EPOLL_MAX_EVENTS]; //使用 epool_wait方式监听加入监听的事件，没有就阻塞,返回值是监听的事件到来的个数 int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis); ...//错误处理到 done处 // Handle all events. ... for (int i = 0; i &lt; eventCount; i++) {//遍历监听到的事件数组 int fd = eventItems[i].data.fd; // 获取 fd uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd.get()) { //如果 监听的事件是 当时设定的 wake fd事件 if (epollEvents &amp; EPOLLIN) {//监听的是读操作 awoken(); //awoken的实质是去 去读监听事件的内容 } else { ... } } else { ... }Done: ; //处理 done的逻辑 // 先处理 native 层的 消息 ... // 在处理 respone ...}void Looper::awoken() { ... uint64_t counter; TEMP_FAILURE_RETRY(read(mWakeEventFd.get(), &amp;counter, sizeof(uint64_t)));//awoke的实质是去读取管道中的内容} 我们在来总结下，Java 层的消息队列建立后，开始循环，在取出下个消息时，若没有消息时，通过 epoll 机制等待被唤醒，而被唤醒后，也就是去读取下内容，将函数返回，我们在看下消息时如何发送的 Handler 消息发送与处理消息的发送 和 处理，都是通过 Handler 完成，先看下它是如何构造的 handler 构造Handler 的构造函数有好几个，但核心就是拿到该线程对应的 Looper对象，有了 Looper对象就有了消息队列，这里以默认构造函数为例看下流程 1234567891011121314151617public Handler() { this(null, false); } public Handler(@Nullable Callback callback, boolean async) { ... mLooper = Looper.myLooper(); // 通过 Looper.mylooper静态方法获取当前线程的消息队列 if (mLooper == null) {//若没有获取到，则说明之前没有初始化过，抛异常 throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); } //赋值其他变量 mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } Handler.sendMessage利用 Handler发送消息，因为消息队列是按照消息发生消息时间来排序的，所以所有发送消息的 API 最后都是调用 sendMessageAtTime 方法 12345678910111213//发送消息，最终将消息入到消息队列中 public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) { MessageQueue queue = mQueue; ...//处理异常 return enqueueMessage(queue, msg, uptimeMillis); } private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) { msg.target = this; // 这句非常重要，这里将 handler的赋值给了 msg.target，以便能让 handler来处理该消息 ... return queue.enqueueMessage(msg, uptimeMillis); //让该消息入队列 } MessageQueue.enqueueMessage/frameworks/base/core/java/android/os/MessageQueue.java 消息入消息队列过程就是一个单链表的插入过程，根据消息队列是否为空，标记 mBlocked 是否为 true, 为 true 则在插入后，立即唤醒主线程去获取消息，唤醒的方式是写入个值到监听的事件 fd 中。 1234567891011121314151617181920212223242526272829303132333435363738394041boolean enqueueMessage(Message msg, long when) { ...//异常处理 synchronized (this) { ...//异常处理 msg.markInUse(); msg.when = when; Message p = mMessages;//获取当前消息队列 boolean needWake; //是否要唤醒消息队列 if (p == null || when == 0 || when &lt; p.when) { // 当消息队列为空，或者当前消息需要立即执行，该msg为首条消息，且唤醒 // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; //设置阻塞唤醒 } else { //正常插入消息到队列的常规case // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) {// 按照msg执行时间插入到对应的位置 prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) {// 假如需要唤醒，就立即唤醒 nativeWake(mPtr); } } return true;} frameworks/base/core/jni/android_os_MessageQueue.cpp 12345678static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) { NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake(); //调用 nativeMsgQueue的 wake 方法}void NativeMessageQueue::wake() { mLooper-&gt;wake();} /system/core/libutils/Looper.cpp 1234567void Looper::wake() { ... uint64_t inc = 1; // wake方法其实就是向wakefd 里面写了一个 1 进去，另一端epoll机制会监听这有内容可以读取 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t))); ...} 所以 handler发送消息的核心就是往消息队列按照消息执行的时间插入到队列中去，如果消息队列为空，或者插入到队首消息，则将该消息作为Head,并唤醒等待，取出消息执行。 好了，接下来我们看下消息处理的流程 Handler.dispatchMessage在 Looper.loop() 方法利用 msg.target.dispatchMessage(msg) 来派发处理消息，处理优先级为 handler.post方法 -&gt; handler构造callback -&gt; 复写handleMessage方法 123456789101112public void dispatchMessage(Message msg) { if (msg.callback != null) { //使用Handler.post(runnbale)调用 handleCallback(msg); } else { if (mCallback != null) {//使用Handler(callback)构造 if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); //回调Handler:handleMessage处理 }} 按照上面的优先级， Handler:post(runnbale)方式, 将 runnbale封装为msg，然后入队列，执行的时候首先处理。 12345678public final boolean post(Runnable r){ return sendMessageDelayed(getPostMessage(r), 0);}private static Message getPostMessage(Runnable r) { Message m = Message.obtain(); m.callback = r; //将runable 赋值给msg属性 return m;} 总结消息循环机制基于 Java层和Native层配合工作，Java层和Native层通过消息队列MessageQueue 连接，而消息的等待，唤醒则是通过 native层的 looper 执行的，handler 游走子线程和主线程之间，不断向绑定线程中的消息队列发送消息和处理消息。 消息队列/Looper 对象 在 Java 层 和 Native 都对应有创建 Java 层消息队列无消息时阻塞，有消息来时，则会被唤醒起来取消息派发执行，底层原理就是通过 native 的 Looper 操作，利用 epoll 机制（一个线程去写值1，触发写入操作，另个线程则一直在监听该事件有值可读取了，唤醒后取出消息执行 Java层的消息机制，围绕3个类展开： Handler: 线程间消息的发送者和处理者，创建时会绑定到某个Looper对象 Looper：每个线程拥有一个该对象，内部有一个消息队列，不断的循环消费消息 MessageQueue: 一个基于链表实现的消息队列，排序为插入队列的时间 对象持有关系如下图，Handler 内部持有 Looper对象，Looper内部持有 MessageQueue对象，所以 MessageQueue 对象的创建是在 Looper初始化中进行， 各个类的在总体核心方法如下： 整体的流程如下: Refs Android应用程序消息处理机制（Looper、Handler）分析 Android消息机制2-Handler(Native层)","link":"/2020/04/04/Android-Handler消息机制/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"博客","slug":"博客","link":"/tags/博客/"},{"name":"独立域名","slug":"独立域名","link":"/tags/独立域名/"},{"name":"yilia","slug":"yilia","link":"/tags/yilia/"},{"name":"七牛云","slug":"七牛云","link":"/tags/七牛云/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"gitment","slug":"gitment","link":"/tags/gitment/"},{"name":"gitalk","slug":"gitalk","link":"/tags/gitalk/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/数据结构与算法/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"北大经济学","slug":"北大经济学","link":"/tags/北大经济学/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"}],"categories":[]}